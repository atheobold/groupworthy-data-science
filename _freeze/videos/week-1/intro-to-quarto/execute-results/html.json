{
  "hash": "8513047988fc8a0ba6190084072ee2a4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Reproducible Deliverables\"\nformat: revealjs\nexecute: \n  eval: false\n---\n\n\n## Principles of Reproducibile Documents\n\n1.  Document is easy to find and organize.\n\n2.  References to data and code work for everyone.\n\n3.  Package dependency is clear.\n\n4.  Code will run the same every time, even if data values change.\n\n5.  Analysis process is well-explained and easy to read.\n\n# Quarto Documents\n\n## Setup Steps\n\n::: {.incremental}\n-   In the YAML, choose a good title.\n\n-   Add your name! \n\n-   Save your `.qmd` file, and name it something meaningful (match the title!)\n\n:::\n\n. . .\n\n-   Your first code chunk should look like this:\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: setup\n\nlibrary(tidyverse)\n```\n````\n:::\n\n\n## Good organization\n\n::: {.incremental}\n-   Use `#` to make section (and sub-section) headings.\n\n-   Each code chunk is **one** unified thought.\n\n-   Text before and after each code chunk motivate your code and explain the output.\n\n-   Make deliberate decisions about what to display!\n\n    -   Does the reader need to see data loading step?\n    -   Does the reader need to see your code?\n    -   Does the reader need to see the output?\n:::\n\n## Naming code chunks\n\nCode chunks should have **explanatory** labels:\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: data-read\n\nmy_data <- read_csv(here::here(\"data\", \n                               \"penguins.csv\")\n                    )\n```\n````\n:::\n\n\n::: {.incremental}\n-   Lets you jump between chunks.\n\n-   Helps you troubleshoot what code chunk is causing render errors.\n\n-   Careful with copy-pasting, duplicate names are not allowed!\n:::\n\n## Setting chunk options\n\nAll code chunk options are specified after a `#|` symbol. \n\n. . .\n\n-   `echo`: Should this code be **shown** (echoed)?\n\n-   `eval`: Should this code be **run** (evaluated)?\n\n-   `include`: Should this code be neither shown nor run?\n\n-   `error`: If there is an error, should that display rather than breaking the\ndocument's ability to render?\n\n-   `warning`: If there is a warning, should that be displayed?\n\n-   `message`: If there is a message, should that be displayed?\n\n## Setting global options for ALL chunks\n\nThe `execute` option of the YAML allows you to declare code chunk options that \nwill hold for **every** code chunk. \n\n</br>\n\n````\n---\ntitle: \"Lab 1\"\nauthor: \"Allison Theobold\"\ndate: \"September 31, 2024\"\nformat: html\nexecute: \n  error: true\n  message: false\n---\n````\n. . .\n\n</br> \n\n(you can always override these for individual chunks)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}