---
title: "Lab 8: Data Frame Functions + Fish"
author: "Instructions"
format: 
  html:
    toc: true
editor: source
execute: 
  error: true
  echo: true
  eval: false
  message: false
  warning: false
---

<!-- add question about pivoted table function -->
<!-- add question about sorted barplot function -->


## Use Variables within a Dataset

Suppose you would like for your `rescale()` function to perform operations on a **variable within a dataset**. Ideally, your function would take in a dataframe and a variable name as inputs and return a dataframe where the variable has been rescaled.

**8. Create a `rescale_column()` function that accepts two arguments: (1) a dataframe and (2) the name(s) of the variable(s) to be rescaled. The body of the function should call the original `rescale_01()` function you wrote previously. Your solution MUST use one of the `rlang` options from class.**

::: callout-tip

If you are struggling with this task, I recommend looking [here](https://rlang.r-lib.org/reference/topic-defuse.html) and  at the slides from class on Wednesday!

:::

```{r}
# Code for Q8.
```

**9. Use your `rescale_column()` function to rescale *both* the `length` and `weight` columns.**

::: callout-warning

I expect that you carry out this process by calling the `rescale_column()` function only ONE time!

:::

```{r}
# original values
fish |> 
 select(length:weight) |> 
 head()

# rescaled values

# Code for Q9.

```

<!-- Another convenient use of pick() is to make a 2d table of counts. Here we count using all the variables in the rows and columns, then use pivot_wider() to rearrange the counts into a grid: -->

<!-- # https://twitter.com/pollicipes/status/1571606508944719876 -->
<!-- count_wide <- function(data, rows, cols) { -->
<!--   data |>  -->
<!--     count(pick(c({{ rows }}, {{ cols }}))) |>  -->
<!--     pivot_wider( -->
<!--       names_from = {{ cols }},  -->
<!--       values_from = n, -->
<!--       names_sort = TRUE, -->
<!--       values_fill = 0 -->
<!--     ) -->
<!-- } -->

<!-- Itâ€™s straightforward to add more variables to the mix. For example, maybe you want an easy way to eyeball whether or not a dataset is linear by overlaying a smooth line and a straight line: -->

<!-- # https://twitter.com/tyler_js_smith/status/1574377116988104704 -->
<!-- linearity_check <- function(df, x, y) { -->
<!--   df |> -->
<!--     ggplot(aes(x = {{ x }}, y = {{ y }})) + -->
<!--     geom_point() + -->
<!--     geom_smooth(method = "loess", formula = y ~ x, color = "red", se = FALSE) + -->
<!--     geom_smooth(method = "lm", formula = y ~ x, color = "blue", se = FALSE)  -->
<!-- } -->
