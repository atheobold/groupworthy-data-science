---
title: "Week 4 Day 1: PA Warm-up"
format: docx
execute: 
  eval: false
---

```{r setup}
#| include: false
#| message: false

library(tidyverse)
library(liver)
library(readxl)
library(ggridges)
```

## `read_xlsx()`

1.  What's wrong with the top of the `gov_spending_per_capita.xlsx` spreadsheet?

2.  Fill in the code you would need to read in the cleanest version of these data.

```{r}
#| echo: true
#| eval: false

military <- read_xlsx("gov_spending_per_capita.xlsx", 
                      sheet =  
                      skip  =  
                      n_max = 
                      )
```

3.  What are the three ways `NA` values were coded in these data?

4.  What would you input into the `na =` argument of `read_xlsx()` to recode these values as `NA`s?

## `pivot_longer()`

![](https://github.com/gadenbuie/tidyexplain/raw/main/images/static/png/original-dfs-tidy.png){fig-alt="Two tables side by side, illustrating the difference between 'wide' and 'long' data formats. The left table labeled 'wide' has columns: 'id,' 'x,' 'y,' and 'z.' The 'id' column contains the values 1 and 2, and the 'x,' 'y,' and 'z' columns contain the values a, b, c, d, e, and f spread across the rows. The right table labeled 'long' has columns: 'id,' 'key,' and 'val.' The 'id' column has repeated values (1 and 2), the 'key' column contains 'x,' 'y,' and 'z,' and the 'val' column contains 'a' through 'f,' corresponding to the wide table but reorganized in a 'long' format."}

5.  Why don't we want to pivot our data manually?

6.  Fill in the code below to pivot the `military` data from wide to long:

```{r}
#| eval: false
#| echo: true

military |> 
  pivot_longer(cols = 
               names_to  = 
               values_to = 
               )

```

7.  What do you notice is weird about some of the values of `Country`?

## `if_any()` & `if_all()`

These functions are used with `filter()` to select rows based on a logical statement applied to multiple columns

-   `if_any()` – returns a logical vector (one element for each row) that is `TRUE` if the logical statement is true for **any** column in the supplied columns

-   `if_all()` – returns a logical vector (one element for each row) that is `TRUE` if the logical statement is true for **all** columns in the supplied columns

8.  Fill in the code to `filter()` the `military` data to only include observations that have **at least one** missing value for the military spending:

```{r}
#| echo: true
#| eval: false

military |> 
  filter(
    if_any(
      .cols = 
      .fns = 
      )
    ) 
```
