---
title: "Simulating Probabilities & Datasets"
format: 
  revealjs:
      theme: [simple, ../style.scss]
      auto-stretch: false
editor: source
execute:
  echo: true
---

```{r setup}
#| include: false
#| message: false
library(tidyverse)

set.seed(435)

fake_data <- tibble(names   = charlatan::ch_name(1000),
        height  = rnorm(1000, mean = 67, sd = 3),
        age     = runif(1000, min = 15, max = 75),
        measure = rbinom(1000, size = 1, prob = 0.6)) |> 
  mutate(supports_measure_A = ifelse(measure == 1, "yes", "no"))

library(openintro)

```

Today we will...

-   Thinking through a probability simulation task
-   Introduce Lab 9
    - Refresher on linear regression
    - Tools for extracting elements from a regression
-   Survey on Experiences in STAT 331 / 531
-   Work time!

# The Birthday Problem

> What the probability that at least two people in a group of randomly selected
people share a birthday?

## Our Task

Simulate the approximate probability that at least two people have the same
birthday (same day of the year, not considering year of birth or leap years).


## Writing a function to...

+ simulate the birthdays of 50 people.
+ count how many birthdays are shared.
+ return whether or not a shared birthday exists.


## Step 1 -- simulate the birthdays of 50 people

```{r}
#| code-line-numbers: false

get_shared_birthdays <- function(n = 50){
  
  bday_data <- tibble(person = 1:n,
                      bday   = sample(1:365, 
                                      size = n, 
                                      replace = TRUE)
                      )
}
```

. . .

::: {.callout-tip}
# Why did I set `replace = TRUE` for the `sample()` function?
:::

## Step 2 -- count how many birthdays are shared

```{r}
#| code-line-numbers: "9-12"

get_shared_birthdays <- function(n = 50){
  
  bday_data <- tibble(person = 1:n,
                      bday   = sample(1:365, 
                                      size = n, 
                                      replace = TRUE)
                      )
  
  double_bdays <- bday_data |> 
    count(bday) |> 
    filter(n >= 2) |> 
    nrow()
  
}
```

## Step 3 -- return whether or not a shared birthday exists

::: {.small}
```{r}
#| code-line-numbers: "13"

get_shared_birthdays <- function(n = 50){
  bday_data <- tibble(person = 1:n,
                      bday   = sample(1:365, 
                                      size = n, 
                                      replace = T)
                      )
  
  double_bdays <- bday_data |> 
    count(bday) |> 
    filter(n >= 2) |> 
    nrow()
  
  double_bdays > 0
}
```
:::

. . .

::: {.callout-tip}
# What type of output is this function returning? 
:::

## Using Function to Simulate Many Probabilities

Use a `map()` function to simulate 1000 datasets.

::: {.midi}
```{r}
#| code-line-numbers: false
sim_results <- map_lgl(.x = 1:1000,
                       .f = ~ get_shared_birthdays(n = 50))

```
:::

. . .

</br>

+ What proportion of these datasets contain at least two people with the same
birthday?

::: {.midi}
```{r}
#| code-line-numbers: false

sum(sim_results) / 1000
```
:::

# Lab 9: Data Simulation Exploration

## Simple Linear Regression (SLR)

If we assume the relationship between $x$ and $y$ takes the form of a **linear function**...

$$
  response = intercept + slope \times explanatory + noise
$$

. . .

We use the following notation for this model:

::: columns
::: {.column width="48%"}
**Population** Regression Model

$Y = \beta_0 + \beta_1 X + \varepsilon$  

where $\epsilon \sim N(0, \sigma)$ is the random noise.
:::

::: {.column width="2%"}
:::

::: {.column width="50%"}
::: {.fragment}
**Fitted** Regression Model 

$\hat{y}_i = \widehat{\beta}_0 + \widehat{\beta}_1 x_i$

where &nbsp; $\widehat{}$ &nbsp; indicates the value was estimated.
:::
:::
:::

## Fitting an SLR Model 

::: panel-tabset

### Question

Regress baby birthweight (response variable) on the pregnant parent's weight gain (explanatory variable).

+ We are assuming there is a linear relationship between how much weight the parent gains and how much the baby weighs at birth.

### `geom_smooth()`

::: {.midi}
When visualizing data, fit a regression line ($y$ on $x$) to your scatterplot.

```{r}
#| code-line-numbers: "4"
#| fig-align: center
#| output-location: column

ncbirths |> 
  ggplot(aes(x = gained, y = weight)) +
  geom_jitter() + 
  geom_smooth(method = "lm") +
  labs(x = "Weight Gained During Pregnancy (lbs)", 
       y = "Birth Weight of Baby (lbs)")
```
:::

### `lm()`

::: {.midi}
The `lm()` function fits a **l**inear regression **m**odel.

+ We use *formula* notation to specify the response variable (LHS) and the explanatory variable (RHS).
+ This code creates an `lm` object.

```{r}
#| code-line-numbers: false

ncbirth_lm <- lm(weight ~ gained, 
                 data = ncbirths)
```
:::
:::

## Model Outputs

::: panel-tabset

### `lm` object

```{r}
#| code-line-numbers: false

summary(ncbirth_lm)
```

### coefficients

```{r}
#| code-line-numbers: false

coefficients(ncbirth_lm)
```

</br>

::: {.fragment}
To grab the slope estimate we would need to...

```{r}
#| code-line-numbers: false

coefficients(ncbirth_lm)[2]
```

...but we don't have any measure of uncertainty!
:::

### `tidy()` coefficients

```{r}
#| eval: false
#| code-line-numbers: false

broom::tidy(ncbirth_lm, 
            conf.int = TRUE, 
            conf.level = 0.9)
```

```{r}
#| echo: false

broom::tidy(ncbirth_lm, 
            conf.int = TRUE, 
            conf.level = 0.9) |>  
  knitr::kable() |> 
  kableExtra::kable_styling(font_size = 30)
```

::: {.fragment}
::: {.callout-tip}
# Confidence Level

You can change the confidence level for the confidence interval in the
`conf.level` argument!
:::
:::
::::

## Grabbing Model Outputs

```{r}
#| code-line-numbers: false

broom::tidy(ncbirth_lm, 
            conf.int = TRUE, 
            conf.level = 0.9) |> 
  filter(term == "gained") |> 
  select(estimate, conf.low, conf.high)
  
```

## Our Goal

![](images/ci_plot.png){fig-alt="A horizontal plot showing 100 simulated 95% confidence intervals (CIs) for estimated regression slopes. Each horizontal line represents one simulated dataset’s estimated slope and its 95% CI. Most intervals are drawn in light blue, while a few are in red—these red lines indicate CIs that do not include the true population slope. A vertical dashed line marks the population slope at 1. The title reads '95% Confidence Intervals of Estimated Regression Slope for 100 Simulated Datasets,' and a caption explains that intervals not including the population slope are highlighted in red. The distribution of intervals is roughly centered around the true slope of 1, with a few red intervals missing it on either side."}

# [Survey on Experiences in STAT 331 / 531](https://forms.gle/wtXGQTFq5yzrX32W6)

::: {.midi}
Anonymous Google Form: <https://forms.gle/wtXGQTFq5yzrX32W6>
:::

. . .

::: {.midi}
> If we get an 85% completion rate I will bring treats to class next Thursday!
:::