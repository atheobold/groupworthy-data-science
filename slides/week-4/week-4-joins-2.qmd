---
title: "Extending Joins, Factors, Clean Variable Names"
format: 
  revealjs:
        theme: [simple, ../style.scss]
editor: source
---

```{r setup}
#| include: false
#| message: false
library(tidyverse)
library(palmerpenguins)
library(ggridges)
library(readxl)
```

```{r}
#| eval: true
#| label: imdb-data
#| include: false
#| message: false
#| warning: false

actors <- read_csv("data/actors.csv")
directors <- read_csv("data/directors.csv")
directors_genres <- read_csv("data/directors_genres.csv")
movies <- read_csv("data/movies.csv")
movies_directors <- read_csv("data/movies_directors.csv")
movies_genres <- read_csv("data/movies_genres.csv")
roles <- read_csv("data/roles.csv")
```

## Thursday, October 17

Today we will...

::: {.small}
+ Debrief PA 4
+ Debrief Lab 3 & Challenge 3
  + Reminder about Lab 3 Peer Review
-   New Material
    -   Extensions to Relational Data
    -   Factors with `forcats`
    -   Clean Variable Names
    -   Package Lifecycle Stages
-   [Lab 4: Childcare Costs in California](../../labs/instructions/lab-4-instructions.qmd)
:::

# Practice Activity 4

# Lab 3 & Challenge 3

<!-- ## Comments from Week 3 -->

<!-- + The [`tidyverse`](https://www.tidyverse.org/packages/) package automatically loads `ggplot2`, `dplyr`, `readr`, etc. -- do not load these twice! -->

<!-- + Do not use `mutate()` + `distinct()`, when you can use `summarize()`! -->
<!--   + We want to pay attention to the **efficiency** of our code. -->


<!-- ## `mutate()` vs `summarise()` -->

<!-- ::: panel-tabset -->
<!-- ### `mutate()` -->

<!-- ![](images/mutate-sketch.JPG) -->

<!-- ### `summarise()` -->

<!-- ![](images/summarise-sketch.JPG){width=85%} -->
<!-- ::: -->

# Extensions to Relational Data


## Relational Data

When we work with multiple tables of data, we say we are working with **relational data**.

+ It is the *relations*, not just the individual datasets, that are important.

. . .

When we work with relational data, we rely on **keys**.

-   A key uniquely identifies an observation in a dataset.
-   A key allows us to relate datasets to each other


## IMDb Movies Data

![](images/imdb-keys.png)

**How can we find each director's active years?**


## Joining Multiple Data Sets

::: panel-tabset
### Data

:::: {.columns}
::: {.column width="50%"}
::: {.small}
```{r}
#| echo: true
directors[1:4,]
```
:::
:::

::: {.column width="50%"}
::: {.small}
```{r}
#| echo: true
movies_directors[1:4,]
```
:::
::: 
::::

:::: {.columns}
::: {.column width="25%"}
:::

::: {.column width="50%"}
::: {.small}
```{r}
#| echo: true
movies[1:4,]
```
:::
:::
::::

### Sketch

```{r}
#| out-width: "90%"
#| fig-align: center
knitr::include_graphics("images/multiple_joins.png")
```

### 1st + 2nd

::: {.small}
```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false

movies_directors |> 
  inner_join(directors, 
             by = join_by(director_id == id)
             )
```
:::

```{r}
#| eval: true
#| echo: false
movies_directors |> 
  inner_join(directors, 
             join_by(director_id == id)) |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "400px") |> 
  kableExtra::kable_styling(font_size = 25)
```

### + 3rd

::: {.small}
```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false
movies_directors |> 
  inner_join(directors, 
             by = join_by(director_id == id)
             ) |> 
  inner_join(movies,
             by = join_by(movie_id == id)
             ) |> 
  rename(movie_name = name)
```
:::

```{r}
#| eval: true
#| echo: false
movies_directors |> 
  inner_join(directors, 
             join_by(director_id == id)) |> 
  inner_join(movies,
             join_by(movie_id == id)) |> 
  rename(movie_name = name) |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "300px") |> 
  kableExtra::kable_styling(font_size = 25)
```

:::


## Joining on Multiple Variables

Consider the `rodent` data from Lab 2.

+ We want to add `species_id` to the rodent measurements.

```{r}
rodent <- read_csv(here::here("labs", 
                              "student", 
                              "data", 
                              "surveys.csv")
                   )

species <- rodent |> 
  select(genus:taxa, species_id) |> 
  distinct()

measurements <- rodent |> 
  select(genus, species, sex:weight) |> 
  rename(genus_name = genus)
```

::: panel-tabset

## Species

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false

species
```

```{r}
#| eval: true
#| echo: false
species |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "300px") |> 
  kableExtra::kable_styling(font_size = 25)
```

## Measurements

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false

measurements
```

```{r}
#| eval: true
#| echo: false
measurements[1:100,] |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "300px") |> 
  kableExtra::kable_styling(font_size = 25)
```
:::

## Join by `species` + `genus`

::: {.small}
```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false

measurements |> 
  full_join(species,
            by = join_by(species == species, 
                         genus_name == genus)
            )
```
:::

```{r}
#| eval: true
#| echo: false
measurements[1:100, ] |> 
  full_join(species,
            by = join_by(species == species, 
                         genus_name == genus)
            ) |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "300px") |> 
  kableExtra::kable_styling(font_size = 25)
```

. . .

</br> 

::: {.small}
**What if a species was included in the `species` dataset, but not in the
`measurement` dataset?**
:::

# Factor Variables


## What is a factor variable?

</br> 

In general, factors are used for: 

1. categorical variables with a fixed and known set of possible values.
  + E.g., `day_born` = Sunday, Monday, Tuesday, ..., Saturday
2. displaying character vectors in non-alphabetical order.


## Eras Tour

Let's consider songs that Taylor Swift played on her Eras Tour. I have randomly
selected 25 songs (and their albums) to consider.

```{r}
#| echo: false

set.seed(2)

full_eras <- read_xlsx("data/TS_data.xlsx", sheet = 1)

eras_data <- full_eras |> 
  slice_sample(n = 25) |> 
  select(Song, Album)
```

```{r}
#| echo: true
#| code-line-numbers: false

eras_data 
```


## Creating a Factor -- Base `R`

::: panel-tabset

## A **character** vector:

::: {.small}
```{r}
#| echo: true
#| code-line-numbers: false

eras_data |> 
  pull(Album)
```
:::

## A **factor** vector:

::: {.small}
```{r}
#| echo: true
#| code-line-numbers: false

eras_data |> 
  pull(Album) |> 
  as.factor()
```
:::
:::

## Creating a Factor -- Base `R`

When you create a factor variable from a vector...

+ Every unique element in the vector becomes a **level**.
+ The levels are ordered alphabetically.
+ The elements are no longer displayed in quotes.


## Creating a Factor -- Base `R`

You can **specify the order of the levels** with the `levels` argument.

```{r}
#| echo: true
#| code-line-numbers: false
#| eval: false

eras_data |> 
  pull(Album) |> 
  factor(levels = c("Fearless",
                    "Speak Now",
                    "Red",
                    "1989",
                    "Reputation",
                    "Lover",
                    "Folklore",
                    "Evermore",
                    "Midnights")
         )
```

## `forcats`

:::: {.columns}
::: {.column width="80%"}
::: {.small}
We use this package to...

+ turn character variables into factors.

+ make factors by discretizing numeric variables.

+ rename or reorder the levels of an existing factor.
:::
:::

::: {.column width="20%"}
```{r}
#| fig-align: center
knitr::include_graphics("https://github.com/rstudio/hex-stickers/blob/main/thumbs/forcats.png?raw=true")
```
:::
::::

::: {.small}
::: callout-note
# `forcats` loads with `tidyverse`!
The packages `forcats` ("for categoricals") helps wrangle categorical variables.
:::
:::


## Creating a Factor -- `fct`

With `fct()`, the levels are automatically ordered in the **order of first appearance**.

::: {.small}
```{r}
#| echo: true
#| code-line-numbers: false

eras_data |> 
  pull(Album) |> 
  fct()
```
:::

## Creating a Factor 

::: {.small}
```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false
eras_data <- eras_data |> 
  mutate(Album = fct(Album))
```
:::

::: {.small}
::: {.callout-warning}
# To change a column type to factor, you must wrap `fct()` in a `mutate()` call.
:::
:::

. . .

</br> 

::: {.small}
I am using `pull()` to display the outcome:

```{r}
#| echo: true
#| code-line-numbers: false
eras_data |> 
  pull(Album) |> 
  fct()
```
:::

## Creating a Factor -- `fct`

You can still **specify the order of the levels** with `level`.

::: {.small}
```{r}
#| echo: true
#| code-line-numbers: false
#| eval: false

eras_data |> 
  pull(Album) |> 
  fct(levels = c("Fearless",
                 "Speak Now",
                 "Red",
                 "1989",
                 "Reputation",
                 "Lover",
                 "Folklore",
                 "Evermore",
                 "Midnights")
      )
```
:::

## Creating a Factor -- `fct`

You can also **specify non-present levels**.

```{r}
#| echo: true
#| code-line-numbers: "3,13"
#| eval: false

eras_data |> 
  pull(Album) |> 
  fct(levels = c("Taylor Swift",
                 "Fearless",
                 "Speak Now",
                 "Red",
                 "1989",
                 "Reputation",
                 "Lover",
                 "Folklore",
                 "Evermore",
                 "Midnights",
                 "The Tortured Poets Department")
      ) 
```

```{r}
#| echo: false
eras_data <- eras_data |> 
  mutate(Album = fct(Album,
                     levels = c("Taylor Swift",
                                "Fearless","Speak Now","Red",
                                "1989","Reputation","Lover",
                                "Folklore","Evermore","Midnights",
                                "The Tortured Poets Department")))
```


## Re-coding a Factor -- `fct_recode`

::: {.small}
Oops, we have a typo in some of our levels! We change existing levels with the
syntax: `"<new level>" = "<old level>"`.
:::

. . .

::: {.small}
```{r}
#| echo: true
#| code-line-numbers: false

eras_data |>
  mutate(Album = fct_recode(.f = Album,
                            "folklore" = "Folklore",
                            "evermore" = "Evermore",
                            "reputation" = "Reputation")
         )
```
:::

## Re-coding a Factor -- `case_when`

::: {.small}
We have similar functionality with the `case_when()` function...
:::

. . .

::: {.small}
```{r}
#| echo: true
#| code-line-numbers: false

eras_data |>
  mutate(Album = case_when(Album == "Folklore" ~ "folklore",
                           Album == "Evermore" ~ "evermore",
                           Album == "Reputation" ~ "reputation",
                           .default = Album),
         Album = fct(Album)) |> 
  pull(Album)
```
:::

## Collapsing a Factor --`fct_collapse`

::: {.small}
Collapse multiple existing levels of a factor with the syntax:

`"<new level>" = c("<old level>", "<old level>", ...)`.
:::

. . .

::: {.small}
```{r}
#| echo: true
#| code-line-numbers: false

eras_data |> 
  mutate(Genre = fct_collapse(.f = Album,
                       "country pop" = c("Taylor Swift", "Fearless"),
                       "pop rock" = c("Speak Now", "Red"),
                       "electropop" = c("1989", "Reputation", "Lover"),
                       "folk pop" = c("Folklore", "Evermore"),
                       "alt-pop" = "Midnights")
         ) |> 
  slice_sample(n = 6)
```
:::

## Re-leveling a Factor --`fct_relevel`

Change the **order** of the levels of an existing factor.

::: panel-tabset

### Original

```{r}
#| echo: true
#| code-line-numbers: false

eras_data |>
  pull(Album) |> 
  levels()
```

### Ordered by Copies Sold

::: {.small}
```{r}
#| echo: true
#| code-line-numbers: false
#| eval: false

eras_data |> 
  pull(Album) |>
  fct_relevel(c("Fearless",
                "1989",
                "Taylor Swift",
                "Speak Now",
                "Red",
                "Midnights",
                "Reputation",
                "Folklore",
                "Lover",
                "Evermore")
              ) |> 
  levels()
```
:::
:::


## Re-ordering Factors in `ggplot2`

::: panel-tabset

### Original

The bars follow the default factor levels.

::: {.small}
```{r}
#| echo: true
#| eval: false
#| code-line-numbers: "2"

full_eras |> 
  mutate(Album = fct(Album)) |> 
  ggplot(mapping = aes(y = Album,
               fill = Album)
         ) +
  geom_bar() +
  theme_minimal() +
  theme(legend.position = "none") +
  labs(x = "",
       y = "",
       title = "Number of Songs Played on the Eras Tour by Album")
```
:::

### Plot

```{r}
#| echo: false
#| 
full_eras |> 
  mutate(Album = fct(Album)) |> 
  ggplot(mapping = aes(y = Album,
               fill = Album)
         ) +
  geom_bar() +
  theme_minimal() +
  theme(legend.position = "none") +
  labs(x = "",
       y = "",
       title = "Number of Songs Played on the Eras Tour by Album")
```

### Specify Levels

::: {.small}
We can order factor levels to order the bar plot.

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: "2-13"

full_eras |> 
  mutate(Album = fct(Album,
                     levels = c("Fearless",
                                "Speak Now",
                                "Red",
                                "1989",
                                "Reputation",
                                "Lover",
                                "Folklore",
                                "Evermore",
                                "Midnights")
                     )
         ) |> 
  ggplot(mapping = aes(y = Album,
               fill = Album)
         ) +
  geom_bar() +
  theme_minimal() +
  theme(legend.position = "none") +
  labs(x = "",
       y = "",
       title = "Number of Songs Played on the Eras Tour by Album")
```
:::

### Plot

```{r}
#| echo: false

full_eras |> 
  mutate(Album = fct(Album,
                     levels = c("Fearless",
                                "Speak Now",
                                "Red",
                                "1989",
                                "Reputation",
                                "Lover",
                                "Folklore",
                                "Evermore",
                                "Midnights")
                     )
         ) |> 
  ggplot(mapping = aes(y = Album,
               fill = Album)
         ) +
  geom_bar() +
  theme_minimal() +
  theme(legend.position = "none") +
  labs(x = "",
       y = "",
       title = "Number of Songs Played on the Eras Tour by Album")
```
:::


## Re-ordering Factors in `ggplot2`

::: {.small}
```{r}

full_eras <- full_eras |> 
  mutate(Album = fct(Album,
                     levels = c("Fearless",
                                "Speak Now",
                                "Red",
                                "1989",
                                "Reputation",
                                "Lover",
                                "Folklore",
                                "Evermore",
                                "Midnights")
                     )
         )
```
:::

::: panel-tabset

### Original

::: {.small}
The ridge plots follow the order of the factor levels.

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: "3"

full_eras |> 
  ggplot(mapping = aes(x = Length, 
                       y = Album, 
                       fill = Album)
         ) +
  geom_density_ridges() +
  theme_minimal() +
  theme(legend.position = "none")+
  labs(x = "Song Length (mins)",
       y = "",
       title = "Length of Songs Played on the Eras Tour by Album")
```
::: 

### Plot

```{r}
#| echo: false

full_eras |> 
  ggplot(mapping = aes(x = Length, 
                       y = Album, 
                       fill = Album)
         ) +
  geom_density_ridges() +
  theme_minimal() +
  theme(legend.position = "none") +
  labs(x = "Song Length (mins)",
       y = "",
       title = "Length of Songs Played on the Eras Tour by Album")
```

### `fct_reorder()`

::: {.small}
Inside `ggplot()`, we can order factor levels by a summary value.

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: "3-5"
full_eras |> 
  ggplot(aes(x = Length, 
             y = fct_reorder(.f = Album,
                             .x = Length,
                             .fun = mean), 
             fill = Album)
         ) +
  geom_density_ridges() +
  theme_minimal() +
  theme(legend.position = "none") +
  labs(x = "Song Length (mins)",
       y = "",
       title = "Length of Songs Played on the Eras Tour by Album")
```
::: 

### Plot

```{r}
#| echo: false
full_eras |> 
  ggplot(mapping = aes(x = Length, 
             y = fct_reorder(.f = Album,
                             .x = Length,
                             .fun = mean), 
             fill = Album)
         ) +
  geom_density_ridges() +
  theme_minimal() +
  theme(legend.position = "none") +
  labs(x = "Song Length (mins)",
       y = "",
       title = "Length of Songs Played on the Eras Tour by Album")
```

:::


## Re-ordering Factors in `ggplot2`

::: panel-tabset

### Original

```{r}
full_eras <- full_eras |> 
  mutate(Single = if_else(Single == "Y", 1, 0))
```

::: {.small}
The legend follows the order of the factor levels.

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: "7"

full_eras |> 
  filter(!Album %in% c("1989","Fearless")) |> 
  group_by(Album, Single) |> 
  summarise(avg_len = mean(Length)) |> 
  ggplot(mapping = aes(x = Single, 
                       y = avg_len, 
                       color = Album)) +
  geom_point(size = 1.5) +
  geom_line() +
  theme_minimal() +
  scale_x_continuous(breaks = c(0,1),
                     labels = c("No", "Yes")
                     ) +
  labs(y = "",
       title = "Are Taylor Swift's Singles Shorter?",
       color = "Album")
```
:::

### Plot

```{r}
#| echo: false

full_eras |> 
  filter(!Album %in% c("1989","Fearless")) |> 
  group_by(Album, Single) |> 
  summarise(avg_len = mean(Length)) |> 
  ggplot(mapping = aes(x = Single, 
                       y = avg_len, 
                       color = Album)) +
  geom_point(size = 1.5) +
  geom_line() +
  theme_minimal() +
  scale_x_continuous(breaks = c(0,1),
                     labels = c("No", "Yes")
                     ) +
  labs(y = "",
       title = "Are Taylor Swift's Singles Shorter?",
       color = "Album")
```

### `fct_reorder2()`

::: {.small}
Inside `ggplot()`, we can order factor levels by the $y$ values associated with the largest $x$ values.

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: 7-9

full_eras |> 
  filter(!Album %in% c("1989","Fearless")) |> 
  group_by(Album, Single) |> 
  summarise(avg_len = mean(Length)) |> 
  ggplot(mapping = aes(x = Single, 
                       y = avg_len, 
                       color = fct_reorder2(.f = Album,
                                            .x = Single,
                                            .y = avg_len)
                       )
         ) +
  geom_point(size = 1.5) +
  geom_line() +
  theme_minimal() +
  scale_x_continuous(breaks = c(0,1),
                     labels = c("No", "Yes")
                     ) +
  labs(y = "",
       title = "Are Taylor Swift's Singles Shorter?",
       color = "Album")
```
:::

### Plot

```{r}
#| echo: false
full_eras |> 
  filter(!Album %in% c("1989","Fearless")) |> 
  group_by(Album, Single) |> 
  summarise(avg_len = mean(Length)) |> 
  ggplot(aes(x = Single, 
             y = avg_len, 
             color = fct_reorder2(.f = Album,
                                  .x = Single,
                                  .y = avg_len))) +
  geom_point(size = 1.5) +
  geom_line() +
  theme_minimal() +
  scale_x_continuous(breaks = c(0,1),
                     labels = c("No","Yes")) +
  labs(y = "",
       subtitle = "Average Song Length",
       color = "Album")
```

::: 

# `janitor` Package


## Clean Variable Names with [`janitor`](https://sfirke.github.io/janitor/)

```{r}
#| include: false
library(readxl)
library(tidyverse)
military <- read_xlsx(here::here("group-activities", 
                                 "week-4", 
                                 "data",
                                 "gov_spending_per_capita.xlsx"),
                sheet = "Share of Govt. spending", 
                skip  = 7, 
                n_max  = 191)

military_clean <- military |> 
  mutate(across(`1988`:`2019`,
                ~ na_if(.x, y = ". .")),
         across(`1988`:`2019`,
                ~ na_if(.x, y = "xxx")))
```

::: {.small}
Data from external sources likely has variable names not ideally formatted for R.

Names may...

+ contain spaces.
+ start with numbers.
+ start with a mix of capital and lower case letters.
:::

. . .

```{r}
#| eval: true
#| echo: true
#| code-line-numbers: false

names(military)[1:12]
```

## Clean Variable Names with [`janitor`](https://sfirke.github.io/janitor/)

::: {.small}
The `janitor` package converts all variable names in a dataset to *snake_case*.

Names will...

+ start with a lower case letter.
+ have spaces filled in with `_`.

```{r}
#| eval: true
#| echo: true
#| code-line-numbers: "3-5"

library(janitor)

military_clean_names <- military |> 
  clean_names()

names(military_clean_names)[1:12]
```
:::


# Lifecycle Stages

## Lifceycle Stages

As packages get updated, the functions and function arguments included in those packages will change.

+ The accepted syntax for a function may change.
+ A function/functionality may disappear.

![[Learn more about lifecycle stages](https://lifecycle.r-lib.org/articles/stages.html) of packages, functions, function arguments in R.](images/lifecycle.png)


## Lifceycle Stages

<center>

![](images/summarize_lifecycle.png){width=70%}

</center>

## Deprecated Functions

::: {.small}
A **deprecated** functionality has a better alternative available and is scheduled for removal.

+ You get a warning telling you what to use instead.
:::
. . .

::: {.small}
```{r}
#| warning: true
#| message: true
#| echo: true
#| code-line-numbers: "2"

military_clean |> 
  filter(across(.cols = Notes:`2019`, 
                .fns = ~ is.na(.x)
                )
         ) 
```
:::

## Deprecated Functions

::: {.small}
You **should not** use deprecated functions!

Instead, we use...

```{r}
#| echo: true
#| code-line-numbers: "2"
military_clean |>
  filter(if_all(.cols = Notes:`2019`, 
                .fns = ~ is.na(.x)
                )
         ) 
```
:::

## Superceded Functions

A **superseded** functionality has a better alternative, but is not going away.

+ This is a softer alternative to deprecation.
+ A superseded function will not give a warning (since there’s no risk if you
keep using it), but the documentation will give you a recommendation.

## [Lab 4: Childcare Costs in California](../../labs/instructions/lab-4-instructions.qmd)

<!-- ## ChatGPT Example... -->

<!-- https://chatgpt.com/share/670b0fd0-d9f0-8012-8d47-aceba68925f4 -->

## To do...

-   **Lab 4: Childcare Costs in California**
    -   Due Sunday (10/20) at 11:59pm
-   **Challenge 4: Open-Ended Analysis**
    -   Due Sunday (10/20) at 11:59pm
-   **Read Chapter 5: Strings + Dates**
    -   **Check-in 5.1 - 5.2** due Tuesday (10/22) at 12:10pm

