---
title: "Extending Joins, Factors, Clean Variable Names"
format: 
  revealjs:
        theme: [simple, ../style.scss]
editor: source
---

```{r setup}
#| include: false
#| message: false

library(tidyverse)
library(readxl)
library(ggridges)
```

```{r}
#| eval: true
#| label: data
#| include: false
#| message: false
#| warning: false

# PA 4 Data

military <- read_xlsx(here::here("group-activities",
                                 "week-4", 
                                 "data", 
                                 "gov_spending_per_capita.xlsx"), 
                      sheet = "Share of Govt. spending", 
                      skip  = 7, 
                      n_max = 190, 
                      na = c(". .", "xxx", "..")
                      )

cont_region <- read_xlsx(here::here("group-activities",
                                 "week-4", 
                                 "data",
                                 "gov_spending_per_capita.xlsx"), 
                      sheet = "Regional totals", 
                      skip = 14) |> 
  filter(Region != "World total (including Iraq)", 
         Region != "World total (excluding Iraq)")

# Lab 4 Data

childcare_costs <- read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2023/2023-05-09/childcare_costs.csv')

counties <- read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2023/2023-05-09/counties.csv')

ca_tax_rev <- read_csv('https://atheobold.github.io/groupworthy-data-science/labs/instructions/data/ca_tax_revenue.csv')
```

## Thursday, October 17

Today we will...

::: columns
::: {.column width="55%"}
::: {.small}
- Lab 3 & Challenge 3
  + Common Themes
  + Package Lifecycle Stages
  + Expectations for Tools Used
  + Reminder about Lab 3 Peer Review
:::
:::

::: {.column width="5%"}
:::

::: {.column width="40%"}
::: {.small}
-   New Material
    -   Relational Data
    -   Filtering Joins (PA 4 Review)
    -   Factors with `forcats`
-   Lab 4
:::
:::
:::


## Lab 3 Common Themes

::: {.midi}
::: {.incremental}
+ **Q1:** The [`tidyverse`](https://www.tidyverse.org/packages/) package
automatically loads `ggplot2`, `dplyr`, `readr`, etc. -- do not load these twice!

- **Q3:** Where did these data come from? How were they collected? What is the
context of these data?
  + **Challenge 3:** When reaching a conclusion with the hypothesis test, what
  does Question 3 refer to?
  
- Saving an f*$# load of objects 
  + Not outputting the results
:::
:::

## Lab 3 Common Themes

::: {.midi}
- **Q5 & Q7**: Not using the "correct" function syntax

```{r}
#| eval: false
#| echo: true
#| label: correct-syntax-across
#| code-line-numbers: false

if_any(.cols = everything(), .fns = ~ is.na(.x))
```
:::

::: {.midi}
::: {.incremental}
- Not using `.x` to specify where the `.cols` input should go will go awry 
  when there are **multiple** function inputs. 
- Using named arguments (e.g., `.cols = `) makes your code more
readable and is part of the code formatting guidelines for this class. 

- Think about "efficient" ways to do things
  + **Q5**: Are you using the same function `across()` multiple columns?
  + **Q6**: Can you calculate multiple summary statistics in one pipeline?
  + **Q10-12**: Is there a way you can get **both** the max *and* min in one
  pipeline?
:::
:::

# Function Lifecycle Stages

## Function Lifceycle Stages

As packages get updated, the functions and function arguments included in those packages will change.

+ The accepted syntax for a function may change.
+ A function/functionality may disappear.

![[Learn more about lifecycle stages](https://lifecycle.r-lib.org/articles/stages.html) of packages, functions, function arguments in R.](images/lifecycle.png){fig-alt="The image shows a flow diagram representing the lifecycle stages of a feature or process. It consists of four colored boxes with arrows connecting them. The green box in the center labeled stable is the main stage. To the left, an orange box labeled experimental has an arrow pointing toward stable, indicating that experimental features can progress to become stable. From stable, one arrow points upward to another orange box labeled deprecated, indicating that stable features can become deprecated. Another arrow points right to a dark blue box labeled superseded, showing that stable features can also be replaced or superseded."}


## Lifceycle Stages

<center>

![](images/mutate_at.png){width=70% fig-alt="The image shows the documentation for the mutate_at() function in R, from the dplyr package for data manipulation. At the top of the documentation it states that this function (and its relatives mutate_all, mutate_if, transmute_all, transmute_if, transmute_at) is superseded. The description states that these functions have been replaced by the pick() or across() functions."}

</center>

## Deprecated Functions

```{r}
#| echo: false
#| eval: true

military_clean <- military |> 
  anti_join(cont_region, 
            by = join_by(Country == Region))
```


::: {.small}
A **deprecated** functionality has a better alternative available and is scheduled for removal.

+ You get a warning telling you what to use instead.
:::

. . .

::: {.small}
```{r}
#| warning: true
#| message: true
#| echo: true
#| code-line-numbers: "2-5"
#| eval: true

military_clean |> 
  filter(across(.cols = -Country, 
                .fns = ~ is.na(.x)
                )
         ) 
```
:::

## Deprecated Functions

::: {.small}
You **should not** use deprecated functions!

Instead, we use...

```{r}
#| echo: true
#| code-line-numbers: "2-5"
#| eval: true

military_clean |>
  filter(if_all(.cols = -Country, 
                .fns = ~ is.na(.x)
                )
         ) 
```
:::

## Superceded Functions

A **superseded** functionality has a better alternative, but is not going away.

+ This is a softer alternative to deprecation.
+ A superseded function will not give a warning (since there’s no risk if you
keep using it), but the documentation will give you a recommendation for what
to use instead.

## What is my job?

</br> 

::: columns
::: {.column width="40%"}
::: {.fragment}
**Teaching you stuff**

</br> 

(Thoughtfully) choosing what to teach and how to teach it.
::: 
:::

::: {.column width="5%"}
:::

::: {.column width="55%"}
::: {.fragment}
**Assessing what you've learned**

</br> 

What do you understand about the tools I've taught you? 

::: {.fragment}
This **is not** the same as assessing if you figured out a way to 
accomplish a given task.
::: 
:::
:::
:::

# Don't Forget to Complete Your Lab 3 Code Review

> Make sure your feedback follows the [code review guidelines](../../code-review/code-review-guidelines.qmd). 

> Insert your review into the comment box! 

## Relational Data

When we work with multiple tables of data, we say we are working with
**relational data**.

+ It is the *relations*, not just the individual datasets, that are important.

. . .

When we work with relational data, we rely on **keys**.

-   A key uniquely identifies an observation in a dataset.
-   A key allows us to relate datasets to each other

## Childcare Costs

::: {.centered}

![](images/childcare-relations.jpg){fig-alt="A figure showing the relations between three different datasets: childcare_costs, counties, and ca_tax_revenue. The childcare_costs dataset has an arrow connecting the variable 'county_fips_code' to the 'county_fips' in the counties dataset. The counties dataset has an arrow connecting the 'county name' variable to the 'entity name' variable in the ca_tax_revenue dataset. Each of the arrows represents the keys (variables) that link each dataset." width=50%}

:::

. . .

::: {.midi}
**Do counties with higher property taxes also have higher childcare costs? Has this relationship changed over time?**
:::

## Mutating Joins 

Add *variables* from a new dataframe to observations in an existing dataframe.

`inner_join()` 

`left_join()`   

`right_join()`  
 

## `inner_join()`

> Keeps observations when their keys are present in **both** datasets.

:::: {.columns}
::: {.column width="50%"}
![](images/join_xy.png){fig-alt="This image shows two tables on the left, labeled 'x' and 'y.' The 'x' table contains two columns: a key column with values 1, 2, and 3, and a value column with 'x1,' 'x2,' and 'x3.' The 'y' table also has two columns: a key column with values 1, 2, and 4, and a value column with 'y1,' 'y2,' and 'y3.'"}
:::
::: {.column width="50%"}
![](images/inner_join.png){fig-alt="This table combines data from both 'x' and 'y.' based on the 'key' column. It contains three columns: 'key,' 'val_x,' and 'val_y.' For key values 1 and 2, the corresponding values from both 'x' and 'y' are shown ('x1' with 'y1' and 'x2' with 'y2'), while the third rows from both original tables are excluded due to the mismatch in key values."}

:::
::::


## `inner_join()`: Childcare Data

::: {.midi}
> Keeps observations when their keys are present in **both** datasets.
:::

```{r}
#| label: counties-inner
#| echo: true
#| eval: false
#| code-line-numbers: false

inner_join(x = counties, 
           y = ca_tax_rev, 
           by = join_by(county_name == entity_name)
           )
```

. . .

::: {.midi}
::: {.callout-important}
# Keys with different names

The "key" columns linking the `counties` and `ca_tax_rev` datasets have
different names. So, we need to use the `join_by()` function to link the names
together! Notice, `county_name` is the column from the `x` dataset (`counties`)
and `entity_name` is the column from the `y` dataset (`ca_tax_rev`). Order 
matters!
:::
:::

## `inner_join()`: Childcare Data

::: {.midi}
> Keeps observations when their keys are present in **both** datasets.


```{r}
#| label: counties-inner-2
#| eval: false
#| echo: true

inner_join(x = counties, 
           y = ca_tax_rev, 
           by = join_by(county_name == entity_name)
           )
```

What counties will remain in the joined dataset?
:::

. . .

::: {.midi}
~~Autauga County~~, ~~Baldwin County~~, ~~Barbour County~~, **Nevada County**, 
**Santa Cruz County**, ...
:::

## More Mutating Joins

::: {.midi}
-   `left_join()` -- keeps only (and all) observations present in the left data set

-   `right_join()` -- keeps only (and all) observations present in the right data set 

-   `full_join()` -- keeps all observations present in **both** data sets
:::

::: {.centered}
![](images/joins.png){width=60% fig-alt="Four Venn diagrams illustrating different types of joins between two datasets, labeled 'x' and 'y.' inner_join(x, y): Shows two overlapping circles with only the intersection shaded, representing records that are common to both 'x' and 'y.' left_join(x, y): Shows two overlapping circles with the left circle ('x') fully shaded and the intersection shaded, representing all records from 'x' and the matching records from 'y.' right_join(x, y): Shows two overlapping circles with the right circle ('y') fully shaded and the intersection shaded, representing all records from 'y' and the matching records from 'x.' full_join(x, y): Shows two overlapping circles with both circles fully shaded, representing all records from both 'x' and 'y,' including those without matches."}

:::


## More Mutating Joins

::: {.midi}
Which counties would **remain** for each of the following joins?

```{r}
#| eval: false
#| echo: true
#| label: mutating-joins
#| code-line-numbers: false

left_join(x = counties, 
          y = ca_tax_rev, 
          by = join_by(county_name == entity_name)
          )
          
right_join(x = counties, 
          y = ca_tax_rev, 
          by = join_by(county_name == entity_name)
          )

full_join(x = counties, 
          y = ca_tax_rev, 
          by = join_by(county_name == entity_name)
          )
```

:::

## Checking Your Intuition

::: panel-tabset

## `left_join()`

::: {.midi}
```{r}
#| eval: false
#| echo: true
#| code-line-numbers: false

counties |> 
  distinct(county_name)
```

```{r}
#| eval: true
#| echo: false

counties |> 
  distinct(county_name) |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "320px") |> 
  kableExtra::kable_styling(font_size = 30)
```

What if a county in `counties` doesn't have a match in `ca_tax_rev`?
:::

## `right_join()`

::: {.midi}
```{r}
#| eval: false
#| echo: true
#| code-line-numbers: false

ca_tax_rev |> 
  distinct(entity_name)
```

```{r}
#| eval: true
#| echo: false

ca_tax_rev |> 
  distinct(entity_name) |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "320px") |> 
  kableExtra::kable_styling(font_size = 30)
```

What if a county in `ca_tax_rev` doesn't have a match in `counties`?
:::

## `full_join()`

**Every county!** 

What if a there are counties that don't have matches?

:::


## Piping Joins

Remember: the dataset you pipe in becomes the **first argument** of the function you are piping into!

+ So if you are using a pipe, you will only be specifying the **right** (`x`) dataset inside the `join_XXX()` function.

. . .

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: false

left_join(x = counties, 
          y = ca_tax_rev, 
          by = join_by(county_name == entity_name)
          )
```

...is equivalent to...

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: false

counties |> 
  left_join(y = ca_tax_rev, 
            by = join_by(county_name == entity_name)
            )
```

## Lab 4 Preview: Joining Multiple Data Sets

Suppose we wanted to compare the taxes and costs of childcare for counties in 
California. To do this, we would need to join **all three** datasets together!

![](images/childcare-relations.jpg){width=50%}

# Practice Activity 4

![](images/military-relational-diagram.jpg){fig-alt="An image of two datasets, one named military_expenditures and one named region_totals. The military_expenditures datast has five (visible) columns titled: Country, Year, Expenditures, Notes, Reporting year. The region_totals dataset has 13 (visible) columns: Region, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 9157, 1958, 1959, 1960, and 1961. The Country column of military_expenditures is highlighted in red and the Region column of the region_totals column is also highlighted in red. The image is highlighting these columns as they are 'keys' linking the two datasets with one another." width=85%}

## Filtering Joins

> Filter *observations* based on values in new dataframe.

## Filtering Joins: `anti_join()`
**Removes** observations when their keys are present in **both** datasets, and **only keeps variables from the first dataset**.

![© Garrick Aden-Buie](https://github.com/gadenbuie/tidyexplain/raw/main/images/anti-join.gif){fig-alt="A looping animation shows two tables being compared under an ‘anti join’ operation. The left table has keys 1 (red), 2 (blue), 3 (green) paired with values x1, x2, x3. The right table has keys 1 (red), 2 (blue), and 4 (purple) paired with values y1, y2, y4. Lines indicate matching keys (1 and 2). The resulting table on the right contains only the rows from the left table that do not have a match in the right: key 3 with x3 (green). Keys 1 and 2 are excluded because they have matches in the right table."}


## Filtering Joins: `anti_join()`

::: panel-tabset

### Using `filter()`

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false

regions <- cont_region |> 
  pull(Region)
  
military |> 
  filter(! Country %in% regions)
```

```{r}
#| echo: false
#| eval: false

military |> 
  filter(! Country %in% regions) |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "200px") |> 
  kableExtra::kable_styling(font_size = 30)
```


### Using `anti_join()` instead

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false
#| message: false
         
military |> 
  anti_join(cont_region, 
            by = join_by(Country == Region))
```

```{r}
#| echo: false
#| eval: true

military |> 
  anti_join(cont_region, 
            by = join_by(Country == Region)) |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "400px") |> 
  kableExtra::kable_styling(font_size = 25)
```

Countries: ~~Africa~~, ~~North Africa~~, **Algeria**, **Libya**, **Morocco**
:::

<!-- ## Filtering Joins: `semi_join()` -->

<!-- Keeps observations when their keys are present in **both** datasets, -->
<!-- **but only keeps variables from the first dataset**. -->

<!-- ![© Garrick Aden-Buie](https://github.com/gadenbuie/tidyexplain/raw/main/images/semi-join.gif){fig-alt="A looping animation shows two tables side by side and the result of a semi join. The left table (x) has keys 1 (red), 2 (blue), 3 (green) paired with x1, x2, x3. The right table (y) has keys 1 (red), 2 (blue), 4 (purple) paired with y1, y2, y4. Matching key rows (1 and 2) are connected. The resulting output table includes only the rows from the left table that have matches in the right table: key 1 with x1 and key 2 with x2. The left row with key 3 is dropped, and no new columns from y are shown."} -->

# Factor Variables

## What is a factor variable?

</br> 

In general, factors are used for: 

1. categorical variables with a fixed and known set of possible values.
  + E.g., `day_born` = Sunday, Monday, Tuesday, ..., Saturday
2. displaying character vectors in non-alphabetical order.

## California Counties

Let's consider the counties included in the `ca_tax_rev` data. I have randomly 
selected 25 counties for us to consider.

```{r}
#| echo: false

set.seed(2)

ca_tax_rev |> 
  distinct(entity_name) |> 
  slice_sample(n = 25) |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "400px") |> 
  kableExtra::kable_styling(font_size = 25)
```

## `forcats`

:::: {.columns}
::: {.column width="80%"}
We use this package to...

+ turn character variables into factors

+ make factors by discretizing numeric variables

+ rename or reorder the levels of an existing factor
:::

::: {.column width="20%"}
```{r}
#| fig-align: center
#| fig-alt: "The image shows a hexagonal logo with a brown border featuring a group of black cats resting inside a cardboard box. The cats appear relaxed, laying on top of one another, with their eyes closed or half-open. The word forcats is written on the side of the box in a light brown color. This image represents the logo of the R package forcats, which is typically used for handling categorical variables (factors) in data analysis within the R programming environment."

knitr::include_graphics("https://github.com/rstudio/hex-stickers/blob/main/thumbs/forcats.png?raw=true")
```
:::
::::

::: callout-note
# `forcats` loads with `tidyverse`!
The packages `forcats` ("for categoricals") helps wrangle categorical variables.
:::

## Creating a Factor -- `fct`

With `fct()`, the levels are automatically ordered in the **order of first appearance**.

::: {.midi}
```{r}
#| echo: true
#| code-line-numbers: false

ca_tax_rev |> 
  pull(entity_name) |> 
  fct()
```
:::

## Creating a Factor 

```{r}
#| echo: true
#| code-line-numbers: false

ca_tax_rev <- ca_tax_rev |> 
  mutate(entity_name = fct(entity_name))
```

::: {.midi}
::: {.callout-warning}
# To change a column type to factor, you must wrap `fct()` in a `mutate()` call.
:::
:::

## Creating a Factor -- `fct`

::: {.midi}
You can **specify the order of the levels** with `level`.
:::

::: {.small}
```{r}
#| echo: true
#| code-line-numbers: false
#| eval: false

eras_data |> 
  pull(Album) |> 
  fct(levels = c("Los Angeles County", 
                 "San Diego County", 
                 "Orange County", 
                 "Riverside County", 
                 "San Bernardino County", 
                 "Santa Clara County", 
                 "Alameda County", 
                 "Sacramento County", 
                 "Contra Costa County", 
                 "Fresno County", 
                 "Kern County", 
                 "Ventura County", 
                 "San Joaquin County", 
                 "San Mateo County". 
                 ...
                 )
      )
```
:::

::: {.midi}
But that seems pretty tedious.
:::

## `fct_reorder()`

::: {.midi}
Often times, we want to reorder a factor based on the values of another 
variable. For example, we might want to reorder the CA counties based on their
mean sales taxes. 
:::

::: {.panel-tabset}

## Code

::: {.midi}
```{r}
#| label: reorder-mutate
#| echo: true
#| code-line-numbers: false
#| eval: false

ca_tax_rev <- ca_tax_rev |> 
  mutate(entity_name = fct_reorder(.f = entity_name,
                                   .x = sales_and_use_taxes,
                                   .fun = mean)
         )
```
:::

## Arguments

::: {.midi}
`.f`: the factor variable you want to reorder

`.x`: the variable you want to the reordering to be based on

`.fun`: the function you want to use when doing the reordering
:::
:::

## `fct_reoder()` with `ggplot()`

::: {.small}
The vast majority of the time we want to reorder a factor because we want our
visualization to look nicer. 
:::

```{r}
#| echo: false

ca_tax_rev |> 
  filter(sales_and_use_taxes < quantile(sales_and_use_taxes, probs = 0.1)) |> 
  ggplot(aes(x = sales_and_use_taxes, 
             y = fct_reorder(.f = entity_name,
                             .x = sales_and_use_taxes,
                             .fun = mean), 
             fill = entity_name)
         ) +
  geom_density_ridges() +
  theme_minimal() +
  theme(legend.position = "none") +
  labs(x = "Sales and Use Taxes",
       y = "") +
  scale_x_continuous(labels = scales::label_dollar())
```

## `fct_reoder()` with `ggplot()`

::: {.small}
So, we could instead do this process **inside** `ggplot()`. 
:::

::: {.small}
```{r}
#| echo: true
#| eval: false
#| code-line-numbers: "4-6"

ca_tax_rev |> 
  filter(sales_and_use_taxes < quantile(sales_and_use_taxes, probs = 0.1))|> 
  ggplot(aes(x = sales_and_use_taxes, 
             y = fct_reorder(.f = entity_name,
                             .x = sales_and_use_taxes,
                             .fun = mean), 
             fill = entity_name)
         ) +
  geom_density_ridges() +
  theme_minimal() +
  theme(legend.position = "none") +
  labs(x = "Sales and Use Taxes",
       y = "") +
  scale_x_continuous(labels = scales::label_dollar())
```
:::

## `fct_reorder2()`

::: {.small}
There might be times were we want to use **two** variables to reorder the levels
of a factor. 
:::

::: {.small}
```{r}
#| echo: true
#| code-line-numbers: 5-7
#| code-fold: true

ca_tax_rev |> 
  filter(sales_and_use_taxes < quantile(sales_and_use_taxes, probs = 0.1)) |> 
  ggplot(aes(x = sales_and_use_taxes, 
             y = total_property_taxes,
             color = fct_reorder2(.f = entity_name,
                                  .x = sales_and_use_taxes,
                                  .y = total_property_taxes)
             )
         ) +
  geom_point(size = 1.5) +
  theme_bw() +
  scale_y_continuous(labels = scales::label_dollar()) +
  scale_x_continuous(labels = scales::label_dollar()) +
  labs(y = "",
       x = "Sales and Use Taxes",
       color = "California County")
```
:::

## Collapsing a Factor --`fct_collapse()`

::: {.midi}
Suppose we want to make a new variable that classifies the county based on its 
population: low, medium, and high. Here, we want to **collapse** existing
levels of a factor. 
:::

. . .

::: {.small}
```{r}
#| echo: true
#| code-line-numbers: false

high_pop <- c(
  "Los Angeles County", "San Diego County", "Orange County", "Riverside County", 
  "San Bernardino County", "Santa Clara County", "Alameda County", 
  "Sacramento County", "Contra Costa County", "Fresno County", "Kern County", 
  "Ventura County", "San Joaquin County", "San Mateo County", 
  "Stanislaus County", "Sonoma County", "Tulare County"
)

medium_pop <- c(
  "Solano County", "Santa Barbara County", "Monterey County", "Placer County", 
  "Merced County", "San Luis Obispo County", "Santa Cruz County", "Marin County", 
  "Yolo County", "Butte County", "El Dorado County", "Imperial County", 
  "Shasta County", "Madera County", "Kings County", "Napa County", 
  "Humboldt County", "Nevada County", "Sutter County", "Mendocino County", 
  "Yuba County", "San Benito County", "Lake County", "Tehama County", 
  "Tuolumne County", "Calaveras County", "Siskiyou County", "Amador County", 
  "Lassen County", "Glenn County", "Del Norte County", "Colusa County"
)

low_pop <- c(
  "Plumas County", "Inyo County", "Mariposa County", "Trinity County", 
  "Mono County", "Modoc County", "Sierra County", "Alpine County"
)
```
:::

## Collapsing a Factor --`fct_collapse()`

::: {.small}
```{r}
#| echo: true
#| eval: true
ca_tax_rev |> 
  mutate(pop_class = fct_collapse(.f = entity_name,
                                  high = high_pop,
                                  medium = medium_pop, 
                                  low = low_pop)
         ) |> 
  select(entity_name, pop_class) |> 
  slice_sample(n = 6)
```
:::

::: {.small}
::: {.callout-important}

The syntax here is: 

`"<new level>" = c("<old level>", "<old level>", ...)`
:::
:::

# Lab 4: Childcare Costs in California

::: columns
::: {.column width="40%"}

:::

::: {.column width="5%"}
:::

::: {.column width="55%"}
![](images/childcare-cost-map.png){fig-alt="The image is a color-coded map of the United States, showing the cost of childcare across different states. The map uses a gradient scale from light green (representing lower costs around $5,000) to dark blue (representing higher costs around $21,000). States with the most expensive childcare, such as Massachusetts ($21,019) and Washington, D.C. ($20,913), are shaded in dark blue, indicating the highest costs. States with lower costs, such as Mississippi ($5,436) and Alabama ($6,001), are shaded in light green. The map's data comes from the Economic Policy Institute, with the source indicated as Money Scoop, and was created using Datawrapper."}
:::
:::

## To do...

-   **Lab 4: Childcare Costs in California**
    -   Due Monday (10/13) at 11:59pm
-   **Week 5: Strings + Dates**
    -   **Check-in 5.1** due Tuesday (10/14) at 8am
    -   **Check-in 5.2** due Thursday (10/14) at 8am

