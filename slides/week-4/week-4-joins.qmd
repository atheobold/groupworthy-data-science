---
title: "Extending Joins, Factors, Clean Variable Names"
format: 
  revealjs:
        theme: [simple, ../style.scss]
editor: source
---

```{r setup}
#| include: false
#| message: false

library(tidyverse)
library(readxl)
library(ggridges)
```

```{r}
#| eval: true
#| label: data
#| include: false
#| message: false
#| warning: false

military <- read_xlsx(here::here("group-activities",
                                 "week-4", 
                                 "data", 
                                 "gov_spending_per_capita.xlsx"), 
                      sheet = "Share of Govt. spending", 
                      skip  = 7, 
                      n_max = 190, 
                      na = c(". .", "xxx", "..")
                      )

cont_region <- read_xlsx(here::here("group-activities",
                                 "week-4", 
                                 "data",
                                 "gov_spending_per_capita.xlsx"), 
                      sheet = "Regional totals", 
                      skip = 14) |> 
  filter(Region != "World total (including Iraq)", 
         Region != "World total (excluding Iraq)")
                      
actors <- read_csv("data/actors.csv")
directors <- read_csv("data/directors.csv")
directors_genres <- read_csv("data/directors_genres.csv")
movies <- read_csv("data/movies.csv")
movies_directors <- read_csv("data/movies_directors.csv")
movies_genres <- read_csv("data/movies_genres.csv")
roles <- read_csv("data/roles.csv")
```

## Thursday, October 17

Today we will...

::: columns
::: {.column width="55%"}
::: {.small}
- Debrief PA 4 (7-minutes)
  + An alternative approach to `filter()`ing 
- Lab 3 & Challenge 3
  + Common Themes
  + Package Lifecycle Stages
  + Expectations for Tools Used
  + Reminder about Lab 3 Peer Review
:::
:::

::: {.column width="5%"}
:::

::: {.column width="40%"}
::: {.small}
-   New Material
    -   Relational Data
    -   Factors with `forcats`
-   Lab 4
:::
:::
:::

# Practice Activity 4

![](images/military-relational-diagram.jpg){fig-alt="An image of two datasets, one named military_expenditures and one named region_totals. The military_expenditures datast has five (visible) columns titled: Country, Year, Expenditures, Notes, Reporting year. The region_totals dataset has 13 (visible) columns: Region, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 9157, 1958, 1959, 1960, and 1961. The Country column of military_expenditures is highlighted in red and the Region column of the region_totals column is also highlighted in red. The image is highlighting these columns as they are 'keys' linking the two datasets with one another." width=85%}

## Filtering Joins

> Filter *observations* based on values in new dataframe.

## Filtering Joins: `anti_join()`
**Removes** observations when their keys are present in **both** datasets, and **only keeps variables from the first dataset**.

![© Garrick Aden-Buie](https://github.com/gadenbuie/tidyexplain/raw/main/images/anti-join.gif){fig-alt="A looping animation shows two tables being compared under an ‘anti join’ operation. The left table has keys 1 (red), 2 (blue), 3 (green) paired with values x1, x2, x3. The right table has keys 1 (red), 2 (blue), and 4 (purple) paired with values y1, y2, y4. Lines indicate matching keys (1 and 2). The resulting table on the right contains only the rows from the left table that do not have a match in the right: key 3 with x3 (green). Keys 1 and 2 are excluded because they have matches in the right table."}


## Filtering Joins: `anti_join()`

::: panel-tabset

### Using `filter()`

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false

regions <- cont_region |> 
  pull(Region)
  
military |> 
  filter(! Country %in% regions)
```

```{r}
#| echo: false
#| eval: false

military |> 
  filter(! Country %in% regions) |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "200px") |> 
  kableExtra::kable_styling(font_size = 30)
```


### Using `anti_join()` instead

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false
#| message: false
         
military |> 
  anti_join(cont_region, 
            by = join_by(Country == Region))
```

```{r}
#| echo: false
#| eval: true

military |> 
  anti_join(cont_region, 
            by = join_by(Country == Region)) |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "400px") |> 
  kableExtra::kable_styling(font_size = 25)
```

Countries: ~~Africa~~, ~~North Africa~~, **Algeria**, **Libya**, **Morocco**
:::

<!-- ## Filtering Joins: `semi_join()` -->

<!-- Keeps observations when their keys are present in **both** datasets, -->
<!-- **but only keeps variables from the first dataset**. -->

<!-- ![© Garrick Aden-Buie](https://github.com/gadenbuie/tidyexplain/raw/main/images/semi-join.gif){fig-alt="A looping animation shows two tables side by side and the result of a semi join. The left table (x) has keys 1 (red), 2 (blue), 3 (green) paired with x1, x2, x3. The right table (y) has keys 1 (red), 2 (blue), 4 (purple) paired with y1, y2, y4. Matching key rows (1 and 2) are connected. The resulting output table includes only the rows from the left table that have matches in the right table: key 1 with x1 and key 2 with x2. The left row with key 3 is dropped, and no new columns from y are shown."} -->


## Lab 3 Common Themes

::: {.midi}
::: {.incremental}
+ **Q1:** The [`tidyverse`](https://www.tidyverse.org/packages/) package automatically loads `ggplot2`, `dplyr`, `readr`, etc. -- do not load these twice!

- **Q3:** Where did these data come from? How were they collected? What is the
context of these data?
  + **Challenge 3:** When reaching a conclusion with the hypothesis test, what
  does Question 3 refer to?
  
- Saving an f*$# load of objects 
  + Not outputting the results
:::
:::

## Lab 3 Common Themes

::: {.midi}
- **Q5 & Q7**: Not using the "correct" function syntax

```{r}
#| eval: false
#| echo: true
#| label: correct-syntax-across
#| code-line-numbers: false

if_any(.cols = everything(), .fns = ~ is.na(.x))
```
:::

::: {.midi}
::: {.incremental}
- Not using `.x` to specify where the `.cols` input should go will go awry 
  when there are **multiple** function inputs. 
- Using named arguments (e.g., `.cols = `) makes your code more
readable and is part of the code formatting guidelines for this class. 

- Think about "efficient" ways to do things
  + **Q5**: Are you using the same function `across()` multiple columns?
  + **Q6**: Can you calculate multiple summary statistics in one pipeline?
  + **Q10-12**: Is there a way you can get **both** the max *and* min in one
  pipeline?
:::
:::

# Lifecycle Stages

## Lifceycle Stages

As packages get updated, the functions and function arguments included in those packages will change.

+ The accepted syntax for a function may change.
+ A function/functionality may disappear.

![[Learn more about lifecycle stages](https://lifecycle.r-lib.org/articles/stages.html) of packages, functions, function arguments in R.](images/lifecycle.png){fig-alt="The image shows a flow diagram representing the lifecycle stages of a feature or process. It consists of four colored boxes with arrows connecting them. The green box in the center labeled stable is the main stage. To the left, an orange box labeled experimental has an arrow pointing toward stable, indicating that experimental features can progress to become stable. From stable, one arrow points upward to another orange box labeled deprecated, indicating that stable features can become deprecated. Another arrow points right to a dark blue box labeled superseded, showing that stable features can also be replaced or superseded."}


## Lifceycle Stages

<center>

![](images/summarize_lifecycle.png){width=70% fig-alt="The image shows the documentation for the summarise() (or summarize(), using the American spelling) function in R, commonly used in the dplyr package for data manipulation. The summarise() function is used to create summary statistics for data frames or tibbles. The key arguments include .data, which is the data frame or tibble input, and ..., which represents name-value pairs of summary functions. The .by and .groups arguments are optional and used to control grouping behavior in the summarization. A key point in the documentation is that returning values with size 0 or greater than 1 in summary functions, such as min(), n(), or sum(), was deprecated as of version 1.1.0. Instead, users are encouraged to use the reframe() function, which replaces the deprecated behavior. The lifecycle badge marks the deprecation of this feature, ensuring that users know that previous versions' behavior should be updated for compatibility with future versions of the package."}

</center>

## Deprecated Functions

```{r}
#| echo: false
#| eval: true

military_clean <- military |> 
  anti_join(cont_region, 
            by = join_by(Country == Region))
```


::: {.small}
A **deprecated** functionality has a better alternative available and is scheduled for removal.

+ You get a warning telling you what to use instead.
:::

. . .

::: {.small}
```{r}
#| warning: true
#| message: true
#| echo: true
#| code-line-numbers: "2"
#| eval: true

military_clean |> 
  filter(across(.cols = -Country, 
                .fns = ~ is.na(.x)
                )
         ) 
```
:::

## Deprecated Functions

::: {.small}
You **should not** use deprecated functions!

Instead, we use...

```{r}
#| echo: true
#| code-line-numbers: "2"
#| eval: true

military_clean |>
  filter(if_all(.cols = -Country, 
                .fns = ~ is.na(.x)
                )
         ) 
```
:::

## Superceded Functions

A **superseded** functionality has a better alternative, but is not going away.

+ This is a softer alternative to deprecation.
+ A superseded function will not give a warning (since there’s no risk if you
keep using it), but the documentation will give you a recommendation for what
to use instead.

## What is my job?

</br> 

::: columns
::: {.column width="40%"}
::: {.fragment}
**Teaching you stuff**

</br> 

(Thoughtfully) choosing what to teach and how to teach it.
::: 
:::

::: {.column width="5%"}
:::

::: {.column width="55%"}
::: {.fragment}
**Assessing what you've learned**

</br> 

What do you understand about the tools I've taught you? 

::: {.fragment}
This **is not** the same as assessing if you figured out a way to 
accomplish a given task.
::: 
:::
:::
:::

# Don't Forget to Complete Your Lab 3 Code Review

> Make sure your feedback follows the [code review guidelines](../../code-review/code-review-guidelines.qmd). 

> Insert your review into the comment box! 

## Relational Data

When we work with multiple tables of data, we say we are working with
**relational data**.

+ It is the *relations*, not just the individual datasets, that are important.

. . .

When we work with relational data, we rely on **keys**.

-   A key uniquely identifies an observation in a dataset.
-   A key allows us to relate datasets to each other

## Childcare Costs

![](images/relational-childcare.jpg){fig-alt=""}

<!-- **How can we find each director's active years?** -->

## Mutating Joins 

Add *variables* from a new dataframe to observations in an existing dataframe.

`left_join()`,   
`right_join()`,   
`inner_join()`,  

## `inner_join()`

Keeps observations when their keys are present in **both** datasets.

:::: {.columns}
::: {.column width="50%"}
![](images/join_xy.png){fig-alt="This image shows two tables on the left, labeled 'x' and 'y.' The 'x' table contains two columns: a key column with values 1, 2, and 3, and a value column with 'x1,' 'x2,' and 'x3.' The 'y' table also has two columns: a key column with values 1, 2, and 4, and a value column with 'y1,' 'y2,' and 'y3.'"}
:::
::: {.column width="50%"}
![](images/inner_join.png){fig-alt="This table combines data from both 'x' and 'y.' based on the 'key' column. It contains three columns: 'key,' 'val_x,' and 'val_y.' For key values 1 and 2, the corresponding values from both 'x' and 'y' are shown ('x1' with 'y1' and 'x2' with 'y2'), while the third rows from both original tables are excluded due to the mismatch in key values."}

:::
::::


## `inner_join()`: Childcare Data


## `inner_join()`: Childcare Data

What if our **key** does not have the same name?

## Piping Joins

Remember: the dataset you pipe in becomes the **first argument** of the function you are piping into!

+ So if you are using a pipe, you will only be specifying the **right** dataset inside the `join` function.

. . .

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: false
inner_join(directors_genres, movies_directors)
```

...is equivalent to...

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: false
directors_genres |> 
  inner_join(movies_directors)
```



## More Mutating Joins

::: {.small}
-   `left_join()` -- keep only (and all) observations present in the left data set

-   `right_join()` -- keep only (and all) observations present in the right data set 

-   `full_join()` -- keep only (and all) observations present in **both** data sets
:::

![](images/joins.png){width=50% fig-alt="Four Venn diagrams illustrating different types of joins between two datasets, labeled 'x' and 'y.' inner_join(x, y): Shows two overlapping circles with only the intersection shaded, representing records that are common to both 'x' and 'y.' left_join(x, y): Shows two overlapping circles with the left circle ('x') fully shaded and the intersection shaded, representing all records from 'x' and the matching records from 'y.' right_join(x, y): Shows two overlapping circles with the right circle ('y') fully shaded and the intersection shaded, representing all records from 'y' and the matching records from 'x.' full_join(x, y): Shows two overlapping circles with both circles fully shaded, representing all records from both 'x' and 'y,' including those without matches."}

</center>


## More Mutating Joins

Which directors would **remain** for each of the following?

::: {.small}
-   `left_join(directors_genres, movies_directors)`
-   `right_join(directors_genres, movies_directors)`
-   `full_join(directors_genres, movies_directors)`
:::

::: columns
::: column
```{r}
#| eval: false
#| echo: true
#| code-line-numbers: false

directors_genres |> 
  distinct(director_id)
```

```{r}
#| eval: false
#| echo: false

directors_genres_subset |> 
  distinct(director_id) |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "320px") |> 
  kableExtra::kable_styling(font_size = 30)
```

:::

::: column
```{r}
#| eval: false
#| echo: true
#| code-line-numbers: false

movies_directors |> 
  distinct(director_id)
```

```{r}
#| eval: false
#| echo: false
movies_directors_subset |> 
  distinct(director_id) |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "320px") |> 
  kableExtra::kable_styling(font_size = 30)
```
:::
:::

## Joining Multiple Data Sets

### Sketch

### 1st + 2nd

### + 3rd

::: {.small}
```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false
movies_directors |> 
  inner_join(directors, 
             by = join_by(director_id == id)
             ) |> 
  inner_join(movies,
             by = join_by(movie_id == id)
             ) |> 
  rename(movie_name = name)
```
:::

```{r}
#| eval: true
#| echo: false
movies_directors |> 
  inner_join(directors, 
             join_by(director_id == id)) |> 
  inner_join(movies,
             join_by(movie_id == id)) |> 
  rename(movie_name = name) |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "300px") |> 
  kableExtra::kable_styling(font_size = 25)
```
:::

# Factor Variables

## What is a factor variable?

</br> 

In general, factors are used for: 

1. categorical variables with a fixed and known set of possible values.
  + E.g., `day_born` = Sunday, Monday, Tuesday, ..., Saturday
2. displaying character vectors in non-alphabetical order.


## Eras Tour

Let's consider songs that Taylor Swift played on her Eras Tour. I have randomly
selected 25 songs (and their albums) to consider.

```{r}
#| echo: false

set.seed(2)

full_eras <- read_xlsx("data/TS_data.xlsx", sheet = 1)

eras_data <- full_eras |> 
  slice_sample(n = 25) |> 
  select(Song, Album)
```

```{r}
#| echo: true
#| code-line-numbers: false

eras_data 
```


## Creating a Factor -- Base `R`

::: panel-tabset

## A **character** vector:

::: {.small}
```{r}
#| echo: true
#| code-line-numbers: false

eras_data |> 
  pull(Album)
```
:::

## A **factor** vector:

::: {.small}
```{r}
#| echo: true
#| code-line-numbers: false

eras_data |> 
  pull(Album) |> 
  as.factor()
```
:::
:::

## `forcats`

:::: {.columns}
::: {.column width="80%"}
::: {.small}
We use this package to...

+ turn character variables into factors.

+ make factors by discretizing numeric variables.

+ rename or reorder the levels of an existing factor.
:::
:::

::: {.column width="20%"}
```{r}
#| fig-align: center
#| fig-alt: "The image shows a hexagonal logo with a brown border featuring a group of black cats resting inside a cardboard box. The cats appear relaxed, laying on top of one another, with their eyes closed or half-open. The word forcats is written on the side of the box in a light brown color. This image represents the logo of the R package forcats, which is typically used for handling categorical variables (factors) in data analysis within the R programming environment."

knitr::include_graphics("https://github.com/rstudio/hex-stickers/blob/main/thumbs/forcats.png?raw=true")
```
:::
::::

::: {.small}
::: callout-note
# `forcats` loads with `tidyverse`!
The packages `forcats` ("for categoricals") helps wrangle categorical variables.
:::
:::


## Creating a Factor -- `fct`

With `fct()`, the levels are automatically ordered in the **order of first appearance**.

::: {.small}
```{r}
#| echo: true
#| code-line-numbers: false

eras_data |> 
  pull(Album) |> 
  fct()
```
:::

## Creating a Factor 

::: {.small}
```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false
eras_data <- eras_data |> 
  mutate(Album = fct(Album))
```
:::

::: {.small}
::: {.callout-warning}
# To change a column type to factor, you must wrap `fct()` in a `mutate()` call.
:::
:::

. . .

</br> 

::: {.small}
I am using `pull()` to display the outcome:

```{r}
#| echo: true
#| code-line-numbers: false
eras_data |> 
  pull(Album) |> 
  fct()
```
:::

## Creating a Factor -- `fct`

You can still **specify the order of the levels** with `level`.

::: {.small}
```{r}
#| echo: true
#| code-line-numbers: false
#| eval: false

eras_data |> 
  pull(Album) |> 
  fct(levels = c("Fearless",
                 "Speak Now",
                 "Red",
                 "1989",
                 "Reputation",
                 "Lover",
                 "Folklore",
                 "Evermore",
                 "Midnights")
      )
```
:::

## Creating a Factor -- `fct`

You can also **specify non-present levels**.

```{r}
#| echo: true
#| code-line-numbers: "3,13"
#| eval: false

eras_data |> 
  pull(Album) |> 
  fct(levels = c("Taylor Swift",
                 "Fearless",
                 "Speak Now",
                 "Red",
                 "1989",
                 "Reputation",
                 "Lover",
                 "Folklore",
                 "Evermore",
                 "Midnights",
                 "The Tortured Poets Department")
      ) 
```

```{r}
#| echo: false
eras_data <- eras_data |> 
  mutate(Album = fct(Album,
                     levels = c("Taylor Swift",
                                "Fearless","Speak Now","Red",
                                "1989","Reputation","Lover",
                                "Folklore","Evermore","Midnights",
                                "The Tortured Poets Department")))
```


## Re-coding a Factor -- `fct_recode`

::: {.small}
Oops, we have a typo in some of our levels! We change existing levels with the
syntax: `"<new level>" = "<old level>"`.
:::

. . .

::: {.small}
```{r}
#| echo: true
#| code-line-numbers: false

eras_data |>
  mutate(Album = fct_recode(.f = Album,
                            "folklore" = "Folklore",
                            "evermore" = "Evermore",
                            "reputation" = "Reputation")
         )
```
:::

## Re-coding a Factor -- `case_when`

::: {.small}
We have similar functionality with the `case_when()` function...
:::

. . .

::: {.small}
```{r}
#| echo: true
#| code-line-numbers: false

eras_data |>
  mutate(Album = case_when(Album == "Folklore" ~ "folklore",
                           Album == "Evermore" ~ "evermore",
                           Album == "Reputation" ~ "reputation",
                           .default = Album),
         Album = fct(Album)) |> 
  pull(Album)
```
:::

## Collapsing a Factor --`fct_collapse`

::: {.small}
Collapse multiple existing levels of a factor with the syntax:

`"<new level>" = c("<old level>", "<old level>", ...)`.
:::

. . .

::: {.small}
```{r}
#| echo: true
#| code-line-numbers: false

eras_data |> 
  mutate(Genre = fct_collapse(.f = Album,
                       "country pop" = c("Taylor Swift", "Fearless"),
                       "pop rock" = c("Speak Now", "Red"),
                       "electropop" = c("1989", "Reputation", "Lover"),
                       "folk pop" = c("Folklore", "Evermore"),
                       "alt-pop" = "Midnights")
         ) |> 
  slice_sample(n = 6)
```
:::

## Re-leveling a Factor --`fct_relevel`

Change the **order** of the levels of an existing factor.

::: panel-tabset

### Original

```{r}
#| echo: true
#| code-line-numbers: false

eras_data |>
  pull(Album) |> 
  levels()
```

### Ordered by Copies Sold

::: {.small}
```{r}
#| echo: true
#| code-line-numbers: false
#| eval: false

eras_data |> 
  pull(Album) |>
  fct_relevel(c("Fearless",
                "1989",
                "Taylor Swift",
                "Speak Now",
                "Red",
                "Midnights",
                "Reputation",
                "Folklore",
                "Lover",
                "Evermore")
              ) |> 
  levels()
```
:::
:::


## Re-ordering Factors in `ggplot2`

::: panel-tabset

### Original

The bars follow the default factor levels.

::: {.small}
```{r}
#| echo: true
#| eval: false
#| code-line-numbers: "2"

full_eras |> 
  mutate(Album = fct(Album)) |> 
  ggplot(mapping = aes(y = Album,
               fill = Album)
         ) +
  geom_bar() +
  theme_minimal() +
  theme(legend.position = "none") +
  labs(x = "",
       y = "",
       title = "Number of Songs Played on the Eras Tour by Album")
```
:::

### Plot

```{r}
#| echo: false
#| 
full_eras |> 
  mutate(Album = fct(Album)) |> 
  ggplot(mapping = aes(y = Album,
               fill = Album)
         ) +
  geom_bar() +
  theme_minimal() +
  theme(legend.position = "none") +
  labs(x = "",
       y = "",
       title = "Number of Songs Played on the Eras Tour by Album")
```

### Specify Levels

::: {.small}
We can order factor levels to order the bar plot.

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: "2-13"

full_eras |> 
  mutate(Album = fct(Album,
                     levels = c("Fearless",
                                "Speak Now",
                                "Red",
                                "1989",
                                "Reputation",
                                "Lover",
                                "Folklore",
                                "Evermore",
                                "Midnights")
                     )
         ) |> 
  ggplot(mapping = aes(y = Album,
               fill = Album)
         ) +
  geom_bar() +
  theme_minimal() +
  theme(legend.position = "none") +
  labs(x = "",
       y = "",
       title = "Number of Songs Played on the Eras Tour by Album")
```
:::

### Plot

```{r}
#| echo: false

full_eras |> 
  mutate(Album = fct(Album,
                     levels = c("Fearless",
                                "Speak Now",
                                "Red",
                                "1989",
                                "Reputation",
                                "Lover",
                                "Folklore",
                                "Evermore",
                                "Midnights")
                     )
         ) |> 
  ggplot(mapping = aes(y = Album,
               fill = Album)
         ) +
  geom_bar() +
  theme_minimal() +
  theme(legend.position = "none") +
  labs(x = "",
       y = "",
       title = "Number of Songs Played on the Eras Tour by Album")
```
:::


## Re-ordering Factors in `ggplot2`

::: {.small}
```{r}

full_eras <- full_eras |> 
  mutate(Album = fct(Album,
                     levels = c("Fearless",
                                "Speak Now",
                                "Red",
                                "1989",
                                "Reputation",
                                "Lover",
                                "Folklore",
                                "Evermore",
                                "Midnights")
                     )
         )
```
:::

::: panel-tabset

### Original

::: {.small}
The ridge plots follow the order of the factor levels.

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: "3"

full_eras |> 
  ggplot(mapping = aes(x = Length, 
                       y = Album, 
                       fill = Album)
         ) +
  geom_density_ridges() +
  theme_minimal() +
  theme(legend.position = "none")+
  labs(x = "Song Length (mins)",
       y = "",
       title = "Length of Songs Played on the Eras Tour by Album")
```
::: 

### Plot

```{r}
#| echo: false

full_eras |> 
  ggplot(mapping = aes(x = Length, 
                       y = Album, 
                       fill = Album)
         ) +
  geom_density_ridges() +
  theme_minimal() +
  theme(legend.position = "none") +
  labs(x = "Song Length (mins)",
       y = "",
       title = "Length of Songs Played on the Eras Tour by Album")
```

### `fct_reorder()`

::: {.small}
Inside `ggplot()`, we can order factor levels by a summary value.

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: "3-5"
full_eras |> 
  ggplot(aes(x = Length, 
             y = fct_reorder(.f = Album,
                             .x = Length,
                             .fun = mean), 
             fill = Album)
         ) +
  geom_density_ridges() +
  theme_minimal() +
  theme(legend.position = "none") +
  labs(x = "Song Length (mins)",
       y = "",
       title = "Length of Songs Played on the Eras Tour by Album")
```
::: 

### Plot

```{r}
#| echo: false
full_eras |> 
  ggplot(mapping = aes(x = Length, 
             y = fct_reorder(.f = Album,
                             .x = Length,
                             .fun = mean), 
             fill = Album)
         ) +
  geom_density_ridges() +
  theme_minimal() +
  theme(legend.position = "none") +
  labs(x = "Song Length (mins)",
       y = "",
       title = "Length of Songs Played on the Eras Tour by Album")
```

:::


## Re-ordering Factors in `ggplot2`

::: panel-tabset

### Original

```{r}
full_eras <- full_eras |> 
  mutate(Single = if_else(Single == "Y", 1, 0))
```

::: {.small}
The legend follows the order of the factor levels.

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: "7"

full_eras |> 
  filter(!Album %in% c("1989","Fearless")) |> 
  group_by(Album, Single) |> 
  summarise(avg_len = mean(Length)) |> 
  ggplot(mapping = aes(x = Single, 
                       y = avg_len, 
                       color = Album)) +
  geom_point(size = 1.5) +
  geom_line() +
  theme_minimal() +
  scale_x_continuous(breaks = c(0,1),
                     labels = c("No", "Yes")
                     ) +
  labs(y = "",
       title = "Are Taylor Swift's Singles Shorter?",
       color = "Album")
```
:::

### Plot

```{r}
#| echo: false

full_eras |> 
  filter(!Album %in% c("1989","Fearless")) |> 
  group_by(Album, Single) |> 
  summarise(avg_len = mean(Length)) |> 
  ggplot(mapping = aes(x = Single, 
                       y = avg_len, 
                       color = Album)) +
  geom_point(size = 1.5) +
  geom_line() +
  theme_minimal() +
  scale_x_continuous(breaks = c(0,1),
                     labels = c("No", "Yes")
                     ) +
  labs(y = "",
       title = "Are Taylor Swift's Singles Shorter?",
       color = "Album")
```

### `fct_reorder2()`

::: {.small}
Inside `ggplot()`, we can order factor levels by the $y$ values associated with the largest $x$ values.

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: 7-9

full_eras |> 
  filter(!Album %in% c("1989","Fearless")) |> 
  group_by(Album, Single) |> 
  summarise(avg_len = mean(Length)) |> 
  ggplot(mapping = aes(x = Single, 
                       y = avg_len, 
                       color = fct_reorder2(.f = Album,
                                            .x = Single,
                                            .y = avg_len)
                       )
         ) +
  geom_point(size = 1.5) +
  geom_line() +
  theme_minimal() +
  scale_x_continuous(breaks = c(0,1),
                     labels = c("No", "Yes")
                     ) +
  labs(y = "",
       title = "Are Taylor Swift's Singles Shorter?",
       color = "Album")
```
:::

### Plot

```{r}
#| echo: false
full_eras |> 
  filter(!Album %in% c("1989","Fearless")) |> 
  group_by(Album, Single) |> 
  summarise(avg_len = mean(Length)) |> 
  ggplot(aes(x = Single, 
             y = avg_len, 
             color = fct_reorder2(.f = Album,
                                  .x = Single,
                                  .y = avg_len))) +
  geom_point(size = 1.5) +
  geom_line() +
  theme_minimal() +
  scale_x_continuous(breaks = c(0,1),
                     labels = c("No","Yes")) +
  labs(y = "",
       subtitle = "Average Song Length",
       color = "Album")
```

::: 

# [Lab 4: Childcare Costs in California](../../labs/instructions/lab-4-instructions.qmd)

::: columns
::: {.column width="40%"}

:::

::: {.column width="5%"}
:::

::: {.column width="55%"}
![](images/childcare-cost-map.png){fig-alt="The image is a color-coded map of the United States, showing the cost of childcare across different states. The map uses a gradient scale from light green (representing lower costs around $5,000) to dark blue (representing higher costs around $21,000). States with the most expensive childcare, such as Massachusetts ($21,019) and Washington, D.C. ($20,913), are shaded in dark blue, indicating the highest costs. States with lower costs, such as Mississippi ($5,436) and Alabama ($6,001), are shaded in light green. The map's data comes from the Economic Policy Institute, with the source indicated as Money Scoop, and was created using Datawrapper."}
:::
:::

## ChatGPT to the Rescue! 

::: columns
::: {.column width="40%"}
> [collapse the CA regions into the 10 Census regions](https://chatgpt.com/c/67103b47-d8ec-8012-bb72-5cb0467ebe18)
:::

::: {.column width="5%"}
:::

::: {.column width="55%"}
![](images/ca-counties.png){fig-alt="The image displays a map of California divided into regions based on the 2020 Census, along with a table listing the counties in each region. The map on the left uses different colors to highlight each of the 10 regions, with areas such as the San Francisco Bay Area and South Coast labeled. A legend at the bottom of the map assigns numbers and colors to each region: Superior California, North Coast, San Francisco Bay Area, Northern San Joaquin Valley, Central Coast, Southern San Joaquin Valley, Inland Empire, Los Angeles County, Orange County, and San Diego/Imperial. On the right side, a table lists the regions by number and their respective counties. For example, Region 1 includes counties like Butte, Colusa, and El Dorado, while Region 8 consists solely of Los Angeles County. Other regions contain a mix of multiple counties, such as Region 3, which includes Alameda, Contra Costa, and San Francisco."}
:::
:::

## dplyr Resources

::: columns
::: {.column width="60%"}
Every group should have a **dplyr** cheatsheet!

**On the Back**: The Combine Tables section gives advice on joining two datasets

- The "Filtering Join" section will be helpful when performing an `anti_join()`!
:::

::: {.column width="5%"}
:::

::: {.column width="35%"}
![](images/dplyr-cheatsheet-back.png){fig-alt="A picture of the dplyr cheatsheet, which contains helpful information on working with data in a variety of ways."}
:::
:::


## To do...

-   **Lab 4: Childcare Costs in California**
    -   Due Sunday (10/20) at 11:59pm
-   **Read Chapter 5: Strings + Dates**
    -   **Check-in 5.1** due Tuesday (10/22) at 12:10pm
    -   **Check-in 5.2** due Thursday (10/24) at 12:10pm

