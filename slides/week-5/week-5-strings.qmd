---
title: "Using `stringr` to Work with Strings"
format: 
  revealjs:
    theme: [simple, ../style.scss]
editor: source
execute: 
  cache: true
---

```{r}
#| include: false
#| message: false
#| label: setup

library(tidyverse)

colleges <- read_csv("https://www.dropbox.com/s/bt5hvctdevhbq6j/colleges.csv?dl=1") 
```

## Tuesday, October 14

Today we will...

+ Layout for Week 5
+ New material
  + String variables
  + Functions for working with strings
  + Regular expressions
+ PA 5.1: Scrambled Message

# Week 5 Layout

# Week 5 Layout 

- Today: Strings with `stringr`
  + Practice Activity: Decoding a Message

. . .

- Thursday: Dates with `lubridate`
  + Practice Activity: Jewel Heist

. . .

- Lab Assignment Solving a Murder Mystery
  + Using `dplyr` + `stringr` + `ludridate`

# String Variables

## What is a string?

A **string** is a bunch of **characters**.

. . .

There is a difference between...

<center>

...a **string** (many characters, one object)...

and

...a **character vector** (vector of strings).

</center>

. . .

```{r}
#| echo: true
#| code-line-numbers: false
#| label: strings-example

my_string <- "Hi, my name is Bond!"
my_string
```

. . .

```{r}
#| echo: true
#| code-line-numbers: false
my_vector <- c("Hi", "my", "name", "is", "Bond")
my_vector
```

## Strings in a Data Frame

We've encountered **a lot** of strings before in the datasets we've worked with. 

::: {.midi}
::: columns
::: {.column width="60%"}
- `penguins`
  + species
  + island
  + sex
:::

::: {.column width="5%"}
:::

::: {.column width="35%"}
- `colleges`
  + STABBR
  + INSTNM
  
- `military`
  + Country
:::
:::
:::

</br>

::: {.midi}
Until now, we've taken for granted the values of these string variables, but
today we're going to learn how to use expressions to look for and / or modify 
specific values!
:::

## Strings in a Data Frame

For the `colleges` dataset:

::: columns
::: {.column width="50%"}
a string is:

```{r}
#| echo: true
#| eval: false
#| label: character-cp-code
#| code-line-numbers: false

colleges$INSTNM[214]
```

</br>

```{r}
#| echo: false
#| label: character-cp

colleges$INSTNM[214] |> 
  as_tibble() |> 
  rename(INSTNM = value) |> 
  knitr::kable() |> 
  kableExtra::kable_styling(font_size = 25)
```

:::

::: {.column width="50%"}
::: {.fragment}
a character vector is:

```{r}
#| label: character-vector-inst-name-code
#| echo: true
#| eval: false
#| code-line-numbers: false

colleges$INSTNM 
```

</br>

```{r}
#| label: character-vector-inst-name
#| echo: false
#| eval: true

colleges$INSTNM |> 
  as_tibble() |> 
  rename(INSTNM = value) |> 
  knitr::kable() |> 
  kableExtra::kable_styling(font_size = 25)
```
:::
:::
:::


## `stringr`

:::: {.columns}
::: {.column width="80%"}
[**Common tasks**]{.large}

+ Identify strings containing a particular pattern.
+ Remove or replace a pattern.
+ Edit a string (e.g., make it lowercase).

:::
::: {.column width="20%"}

```{r}
#| fig-align: center
#| fig-alt: "A green hex sticker for the stringr package in R. The sticker has a violin and under the violin the text 'stringr' is printed."
knitr::include_graphics("https://github.com/rstudio/hex-stickers/blob/main/PNG/stringr.png?raw=true")
```
:::
::::

::: callout-note 
+ The `stringr` package loads with `tidyverse`.
+ All functions are  of the form `str_xxx()`.
:::

## `string =`

::: {.midi}
None of the `stringr` functions have a `.data = ` argument! These functions only
accept a character vector (`string = `) as an input. 

```{r}
#| echo: true
#| error: true
#| code-line-numbers: false

str_detect(data = colleges, 
           string = INSTNM, 
           pattern = "California")
```
:::

. . .

</br>

::: {.midi}
So, these functions will need to be **combined** with functions from `dplyr` to
work with a dataset!
:::

## `pattern = `

The `pattern` **argument** appears in many `stringr` functions.

- The pattern **must** be supplied inside quotes.

::: {.midi}
```{r}
#| eval: false
#| echo: true
#| code-line-numbers: false

str_detect(colleges$INSTNM, 
           pattern = "Polytechnic")

str_remove(colleges$INSTNM, 
           pattern = "(University|College)")

str_replace(colleges$INSTNM, 
            pattern = "$u", 
            replacement = "U")

```
:::

<br>

. . .

Let's talk more about what some of these symbols mean.

<!-- The real power of these `str_xxx` functions comes when you specify the `pattern` using **regular expressions**! -->

<!-- ```{r} -->
<!-- #| fig-align: center -->
<!-- #| out-width: 70% -->
<!-- #| fig-alt: "The image is a comic strip from xkcd titled 'Regular Expressions.' It humorously portrays a programmer's overconfidence in using regular expressions to solve complex text processing tasks. In the first panel, a stick figure declares, 'EVERYBODY STAND BACK,' and in the second panel, they assert, 'I KNOW REGULAR EXPRESSIONS,' suggesting that their expertise is both a warning and a badge of honor. This reflects the sentiment that while regular expressions are powerful tools in programming, they can also lead to intricate and hard-to-maintain code if not used judiciously." -->

<!-- knitr::include_graphics("images/regular_expressions.png") -->
<!-- ``` -->
# Regular Expressions

# Regular Expressions

> "Regular expressions are a very terse language that allow you to describe patterns in strings."
>
> *R for Data Science*

## Regular Expressions

**...are tricky!**

+ There are lots of new symbols to keep straight.
+ There are a lot of cases to think through.

</br>

We're going to focus on:

::: columns
::: {.column width="40%"}
- anchors
- quantifiers 
:::

::: {.column width="5%"}
:::

::: {.column width="55%"}
- character classes
- groups
:::
:::

<!-- ## Special Characters -->

<!-- There is a set of characters that have a specific meaning when using regex. -->

<!-- + The `stringr` package **does not** read these as normal characters. -->
<!-- + These characters are: -->

<!-- <center> -->

<!-- `.` `^`  `$` `\`  `|` `*` `+` `?` `{` `}` `[` `]` `(` `)` -->

<!-- </center> -->


## Anchor Characters: `^ $`

::: columns
::: {.column width="48%"}
::: {.small}
`^` -- looks at the beginning of a string.

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false

str_subset(colleges$INSTNM, 
           pattern = "^California State")
```

```{r}
#| echo: false
#| eval: true
#| code-line-numbers: false

str_subset(colleges$INSTNM, 
           pattern = "^California State") |> 
  as_tibble() |> 
  rename(INSTNM = value) |> 
  knitr::kable() |> 
  kableExtra::kable_styling(font_size = 25)
```
:::

:::

::: {.column width="2%"}
:::

::: {.column width="50%"}
::: {.fragment}
::: {.small}
`$` -- looks at the end of a string.

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false

str_subset(colleges$INSTNM, 
           pattern = "State University$")
```

```{r}
#| echo: false
#| code-line-numbers: false

str_subset(colleges$INSTNM, 
           pattern = "State University$") |> 
  as_tibble() |> 
  rename(INSTNM = value) |> 
  knitr::kable() |> 
  kableExtra::kable_styling(font_size = 25)
```
:::

:::
:::
:::


## Quantifier Characters: `+ *`

::: {.small}
::: columns
::: {.column width="40%"}

`+` -- occurs 1 or more times

```{r}
#| echo: true
#| code-line-numbers: false
#| eval: false

str_subset(colleges$INSTNM, 
           pattern = "St\\.+")
```

::: {.fragment}
```{r}
#| echo: false
#| code-line-numbers: false
#| eval: true

str_subset(colleges$INSTNM, pattern = "St\\.+") |> 
  as_tibble() |> 
  rename(INSTNM = value) |> 
  knitr::kable() |> 
  kableExtra::kable_styling(font_size = 25)
``` 
:::
:::

::: {.column width="5%"}
:::

::: {.column width="55%"}
::: {.fragment}
`*` -- occurs 0 or more times

```{r}
#| echo: true
#| code-line-numbers: false
#| eval: false

str_subset(colleges$INSTNM, 
           pattern = "\\s*-\\s*")

```

::: {.fragment}
```{r}
#| echo: false
#| code-line-numbers: false
#| eval: true

str_subset(colleges$INSTNM, 
           pattern = "\\s*-\\s*") |> 
  as_tibble() |> 
  rename(INSTNM = value) |> 
  knitr::kable() |> 
  kableExtra::kable_styling(font_size = 25)

```
:::
:::
:::
:::
:::


## Quantifier Characters: `{}`

::: {.small}
::: columns
::: {.column width="40%"}

`{n}` -- occurs exactly n times

```{r}
#| echo: true
#| code-line-numbers: false
#| eval: false

str_subset(colleges$INSTNM, 
           pattern = "[A-Z]{4}")
```

::: {.fragment}
```{r}
#| echo: false
#| eval: true

str_subset(colleges$INSTNM, pattern = "[A-Z]{4}") |> 
  as_tibble() |> 
  rename(INSTNM = value) |> 
  knitr::kable() |> 
  kableExtra::kable_styling(font_size = 25)
```
:::
:::

::: {.column width="5%"}
:::

::: {.column width="55%"}
::: {.fragment}

`{n,m}` -- occurs between n and m times


```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false

str_subset(colleges$INSTNM, 
           pattern = "[A-Z]{4,6}")
```

::: {.fragment}
```{r}
#| echo: false
#| eval: true
#| code-line-numbers: false

str_subset(colleges$INSTNM, pattern = "[A-Z]{4,6}") |> 
  as_tibble() |> 
  rename(INSTNM = value) |> 
  knitr::kable() |> 
  kableExtra::kable_styling(font_size = 25)
```

::: {.callout-tip}
## Want **at least 4**? `{4,}`
:::
:::
:::
:::
:::
:::

## Character Groups: `()`

::: {.small}
+ `()` creates a group of characters
+ We can specify "either" / "or" within a group using `|`.

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false

str_subset(colleges$INSTNM, 
           pattern = "(T|t)ech")
```
:::

```{r}
#| echo: false
#| eval: true
#| code-line-numbers: false

str_subset(colleges$INSTNM, 
           pattern = "(T|t)ech") |> 
  as_tibble() |> 
  rename(INSTNM = value) |> 
  knitr::kable() |> 
  kableExtra::kable_styling(font_size = 25)
```

## Character Classes: `[]`

::: {.midi}
`[ ]`  -- specifies a range of characters.
:::

::: {.small}
::: columns
::: {.column width="45%"}
+ [A-Z] or [:upper:] matches any capital letter.
+ [a-z] or [:lower:] matches any lowercase letter.
+ [A-z] or [:alpha:] matches any letter
+ [0-9] or [:digit:] matches any number
+ [:alnum:] matches any alpha numeric character
+ [:punct:] matches any punctuation character
:::

::: {.column width="5%"}
:::

::: {.column width="50%"}
::: {.fragment}
```{r}
#| echo: true
#| code-line-numbers: false
#| eval: false

str_subset(colleges$INSTNM, 
           pattern = "[A-Z]{4}")

str_subset(colleges$INSTNM, 
           pattern = "[:digit:]+")

str_subset(colleges$INSTNM, 
           pattern = "[:punct:]{1,}")
```
:::
:::
:::
:::

## Excluding Characters

::: {.midi}
`[^ ]`  -- specifies characters **not** to match on
:::

::: {.small}
::: columns
::: {.column width="50%"}
```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false

str_subset(colleges$INSTNM, 
           pattern = "[^y]$")
```

```{r}
#| echo: false
#| eval: true
#| code-line-numbers: false

str_subset(colleges$INSTNM, 
           pattern = "[^y]$") |> 
  as_tibble() |> 
  rename(INSTNM = value) |> 
  knitr::kable() |> 
  kableExtra::kable_styling(font_size = 25)
```
:::

::: {.column width="5%"}
:::

::: {.column width="45%"}

::: {.fragment}

[Beware: a `^` doesn't always mean "not"]{.large}

</br>

**Starts with "University"**

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false

str_subset(colleges$INSTNM, 
           pattern = "^University")
```


**[Does not]{.underline} starts with "University"**

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false

str_subset(colleges$INSTNM, 
           pattern = "^[^University]")
```
:::
:::
:::
:::

# Let's use these expressions!

# Detecting Patterns

## `str_detect()`

Returns a **logical vector** indicating whether the pattern was found in each element of the supplied vector.

::: {.midi}
```{r}
#| echo: true
#| code-line-numbers: false

my_vector <- c("Hello,", 
               "my name is", 
               "Bond", 
               "James Bond")


str_detect(my_vector, pattern = "Bond")
```
:::

. . .

:::{.midi}
::: columns
::: {.column width="40%"}
+ Pairs well with `filter()`
:::

::: {.column width="5%"}
:::

::: {.column width="55%"}
+ Works with `summarise()` 
    + `sum` (to get total matches)
    + `mean` (to get proportion of matches)
:::
:::
:::

## `str_detect()` with `filter()`

> Which colleges in the dataset have "Polytechnic" in their name?

```{r}
#| echo: true
#| label: str-detect-filter
#| eval: false
#| code-line-numbers: false

colleges |> 
  filter(str_detect(INSTNM, pattern = "Polytechnic"))
```

</br>

```{r}
#| echo: false
#| label: str-detect-filter-code
#| eval: true

colleges |> 
  filter(str_detect(INSTNM, pattern = "Polytechnic")) |> 
  knitr::kable() |> 
  kableExtra::kable_styling(font_size = 25)
```


## `str_detect()` with `summarize()`

> How many colleges in the `colleges` dataset have "Polytechnic" in their name?

```{r}
#| echo: true
#| label: str-detect-summarize
#| code-line-numbers: false

colleges |> 
  summarize(
    count_polytech = sum(
      str_detect(INSTNM, pattern = "Polytechnic")
      ) 
    )
```

# Replace / Remove Patterns

## `str_replace()`

> replace the **first** matched pattern in each string

```{r}
#| echo: true
#| code-line-numbers: false

str_replace(my_vector, 
            pattern = "Bond", 
            replace = "Franco")
```

## `str_replace()` with `mutate()`

> Make capitalization of "University" consistent

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false

colleges |> 
  mutate(INSTNM = str_replace(INSTNM, 
                              pattern = "$u", 
                              replacement = "U")
         )
```

```{r}
#| echo: false
#| eval: true

colleges |> 
  mutate(INSTNM = str_replace(INSTNM, 
                              pattern = "$u", 
                              replacement = "U")
         ) |> 
  knitr::kable() |> 
  kableExtra::kable_styling(font_size = 25)
```


## `str_remove()`

> remove the **first** matched pattern in each string

```{r}
#| echo: true
#| code-line-numbers: false

str_remove(my_vector, 
           pattern = "Bond")
```

</br> 

::: {.midi}
::: {.callout-note collapse="true"}
## Related Functions

This is a special case of  `str_replace(x, pattern, replacement = "")`.
:::
:::

## `str_remove()` with `mutate()`

> Remove "College" or "University" at the end of each name so only the main institution name remains.

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false

colleges |> 
  mutate(INSTNM = str_remove(INSTNM, 
                             pattern = "(College|University)"
                             )
         )
```

```{r}
#| echo: false
#| eval: true

colleges |> 
  mutate(INSTNM = str_remove(INSTNM, 
                             pattern = "(College|University)"
                             )
         ) |> 
  knitr::kable() |> 
  kableExtra::kable_styling(font_size = 25)
```

# Find the Length of a String

## `str_length()`

> returns number of elements (characters) of a string

```{r}
#| echo: true
colleges |> 
  mutate(
    name_length = str_length(INSTNM)
         ) |> 
  select(INSTNM, name_length)
```

# Change the Length

> shorten or lengthen a string to a specified length

::: panel-tabset

### `str_sub()`

::: {.midi}
Extract values of a string based on a starting and ending location.
:::

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false

colleges |> 
  mutate(short_name = str_sub(INSTNM, 
                                  start = 1,
                                  end = 8)
         )
```

### `str_pad()`

::: {.midi}
Make every string have a fixed length (width)
:::

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false

colleges |> 
  mutate(long_name = str_pad(INSTNM, 
                             width = 20, 
                             pad = "_", 
                             side = "both")
         )
```

:::

# Modify Characters

## Edit Capitalization of Strings

::: {.small}
Convert letters in a string to a specific capitalization format.
:::

::: panel-tabset

### [`str_to_lower()`]{.midi}

::: {.small}
> converts all letters in a string to lowercase.

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false

colleges |> 
  mutate(INSTNM = str_to_lower(INSTNM))
```

```{r}
#| echo: false
#| eval: true

colleges |> 
  mutate(INSTNM = str_to_lower(INSTNM)) |> 
  knitr::kable() |> 
  kableExtra::kable_styling(font_size = 25)
```
:::

### [`str_to_upper()`]{.midi}

::: {.small}
> converts all letters in a string to uppercase.

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false

colleges |> 
  mutate(INSTNM = str_to_upper(INSTNM))
```

```{r}
#| echo: false
#| eval: true

colleges |> 
  mutate(INSTNM = str_to_upper(INSTNM)) |> 
  knitr::kable() |> 
  kableExtra::kable_styling(font_size = 25)
```
:::

### [`str_to_title()`]{.midi}

::: {.small}
> converts the first letter of each word to uppercase.

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false

colleges |> 
  mutate(INSTNM = str_to_title(INSTNM))
```

```{r}
#| echo: false
#| eval: true

colleges |> 
  mutate(INSTNM = str_to_title(INSTNM)) |> 
  knitr::kable() |> 
  kableExtra::kable_styling(font_size = 25)
```
:::
:::

# Handling Whitespace

## `str_trim()`

> removes whitespace from start and end of string

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false

colleges |> 
  mutate(
    INSTNM = str_trim(INSTNM, side = "both")
         )
```

# Joining Strings

## `str_c()`

> join multiple strings into a single character vector

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false

colleges |> 
  mutate(
    address = str_c(CITY, STABBR, ZIP, sep = ", ")
         )
```

::: callout-note
Similar to `paste()` and `paste0()` but with more precision.
:::

## Tips for String Success

+ Refer to the [`stringr` cheatsheet](https://posit.co/wp-content/uploads/2022/10/strings-1.pdf)
+ Refer to your handout!

+ Remember that `str_xxx` functions need the first argument to be a 
**vector of strings**, not a **dataset**!
  + You will use these functions *inside* `dplyr` verbs like `filter()` or
  `mutate()`.

# PA 5.1: Scrambled Message

::: columns
::: {.column width="40%"}
In this activity, you will use functions from the `stringr` package and regular
expressions to decode a message.
:::

::: {.column width="5%"}
:::

::: {.column width="55%"}
![](images/scrabble-tiles.jpg){fig-alt="A pile of tiles from the game of Scrabble."}
:::
:::

## This activity will require knowledge of:

::: columns
::: {.column width="60%"}
::: {.small}
- functions from `dplyr`
- `stringr` functions for previewing string contents
- regular expressions for locating patterns
- `stringr` functions for removing whitespace
- `stringr` functions for truncating strings 
- `stringr` functions for replacing patterns
- `stringr` functions for combining multiple strings 
:::
:::

::: {.column width="5%"}
:::

::: {.column width="35%"}
[**None of us have all these abilities. Each of us has some of these abilities.**]{.midi}

:::
:::

<!-- ## stringr Resources -->

<!-- ::: columns -->
<!-- ::: {.column width="60%"} -->
<!-- Every group should have a **stringr** cheatsheet! -->

<!-- ::: {.small} -->
<!-- **On the Front**:  -->

<!-- - Detecting matches (e.g., Does a string have a specific pattern?) -->
<!-- - Subsetting strings (e.g., Extract strings with specific patterns!) -->
<!-- - Managing lengths (e.g., How long are the strings? Removing whitespace!) -->
<!-- - Mutating strings (e.g., Replace specific patterns!) -->
<!-- - Join & Flatten (e.g., Collapsing multiple strings into a single string!) -->
<!-- ::: -->
<!-- ::: -->

<!-- ::: {.column width="5%"} -->
<!-- ::: -->

<!-- ::: {.column width="35%"} -->
<!-- ![](images/stringr-cheatsheet.png){fig-alt=""} -->

<!-- ::: -->
<!-- ::: -->

<!-- ## Pair Programming Expectations -->

<!-- ::: columns -->
<!-- ::: {.column width="49%"} -->
<!-- **Typer** -->

<!-- ::: {.small} -->
<!-- -   Reads prompt and ensures Talker understands what is being asked.  -->
<!-- -   Types the code specified by the Talker into the Quarto document. -->
<!-- -   Runs the code provided by the Talker.  -->
<!-- -   Works with Talker to debug the code.  -->
<!-- -   Evaluates the output.   -->
<!-- -   Works with Talker to write code comments.  -->
<!-- ::: -->
<!-- ::: -->

<!-- ::: {.column width="2%"} -->
<!-- ::: -->

<!-- ::: {.column width="49%"} -->
<!-- ::: {.fragment} -->
<!-- **Talker** -->

<!-- ::: {.small} -->
<!-- -   Reads out instructions or prompts -->
<!-- -   Directs the Typer what to type.  -->
<!-- -   Talks with Typer about their ideas.  -->
<!-- -   Manages resources (e.g., cheatsheets, textbook, slides).  -->
<!-- -   Works with Typer to debug the code.  -->
<!-- -   Works with Typer to write code comments.  -->
<!-- ::: -->
<!-- ::: -->
<!-- ::: -->
<!-- ::: -->

## Pair Programming Expectations

```{r}
#| echo: false
#| fig-alt: "A diagram shows a collaborative software development process in four stages arranged in a cycle. At the top, a woman speaks with the label 'VOCALIZE.' To the right, she points to a diagram with the label 'EXPLAIN.' At the bottom, a man types on a laptop with the label 'IMPLEMENT.' On the left, a computer monitor displays a bug symbol with the label 'DEBUG.' Arrows connect the stages in a loop: Vocalize → Explain → Implement → Debug → back to Vocalize."

knitr::include_graphics(here::here("group-activities", 
                                   "collab-process.png")
                        )
```

## External Resources

During the Practice Activity, you **are not** permitted to use Google or ChatGPT
for help. 
. . .

</br> 

You **are** permitted to use:

- the handout, 
- the `stringr` cheatsheet, 
- the course textbook, and
- the course slides. 

## Submission

> Submit the name of the movie the quote is from. 

- Each person will input the full name of the movie the scrambled message is
from into the PA5 quiz. 
- The person who last occupied the role of Typer will submit the link for your 
Colab notebook (don't forget to use the share link!)
  + Only one submission per group!

# 5-minute break

## Team Assignments - 9am

::: {.centered}
![](images/section-70-seats.png){width=75%}
:::

::: {.small}
The person who has the most pets starts as the Typer (listening to explanations
from the Talker)!
:::

## Team Assignments - 12pm

::: {.centered}
![](images/section-71-seats.png){width=75%}
:::

::: {.small}
The person who has the most pets starts as the Typer (listening to explanations
from the Talker)!
:::

# Exit Ticket
