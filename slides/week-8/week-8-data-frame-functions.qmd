---
title: "Taming the Curly Braces: Writing Your Own Tidyverse Functions"
format: 
  revealjs:
      theme: [simple, ../style.scss]
      auto-stretch: false
editor: source
execute: 
  eval: false
---

```{r}
#| include: false
#| message: false
#| eval: true

library(tidyverse)
library(palmerpenguins)
```


## Tuesday, November 4

Today we are going to do a hands-on coding activity! We will create our own
versions of the `table()` and `prop.table()` base R functions. 

. . .

This will help us...

- explore lazy evaluation
- learn more about the `{{ }}` operator 
- figure out when we need to use functions like `all_of()` and `pick()`
- write more complex functions

# Last Week...

## We learned about writing functions!

::: {.midi}
Specifically, we learned about: 

::: columns
::: {.column width="50%"}
- function syntax
- optional & required arguments
:::

::: {.column width="50%"}
- input validation
- last expression returns
:::
:::

```{r}
#| echo: true
#| eval: true
#| code-line-numbers: false

add_something <- function(x, something = 2){
  stopifnot(is.numeric(x), is.numeric(something))
  
  x + something
}
```
:::

</br>

::: {.small}

```{r}
#| echo: true
#| eval: true
#| code-line-numbers: false

x <- 15:22
```

::: columns
::: {.column width="40%"}
```{r}
#| echo: true
#| eval: true
#| code-line-numbers: false

add_something(x)
```
:::


::: {.column width="55%"}
```{r}
#| echo: true
#| eval: true
#| code-line-numbers: false
#| error: true

add_something(x, something = "dog")
```
:::
:::
:::

# Writing Data Frame Functions

## Moving Beyond Vectors

This week, we're writing functions that take a data frame and variable names as
arguments. 

These functions can be incredibly powerful, but they require us 
to learn some interesting details about how some of the functions we've grown
very accustomed to (e.g., `select()`, `mutate()`, `group_by()`) work
"behind the scenes."

. . .

</br>

We are going to use a hands-on activity to explore these concepts! 

## Open the "Tidy Eval" Colab Notebook Posted on Canvas

In the Week 8 Module, navigate to the "Lecture Slides" section. 

Click on the "Tidy Eval" Colab Notebook link. 

Make a copy of the notebook (like you do for Practice Activities)!

```{r}
#| echo: false
#| eval: true

countdown::countdown(minutes = 2)
```

# Our Goal

. . .

> Recreate the `table()` function in R


## Let's Explore the `table()` Function First

Let's start with **one** categorical variable.

. . .

```{r}
#| echo: true
#| eval: true
#| code-line-numbers: false

table(penguins$species)
```

. . .

</br>

::: {.callout-tip}
# Function Design
What do you notice about the layout of the table?
:::

## Let's Explore the `table()` Function First

Okay, let's add a second categorical variable. 

```{r}
#| echo: true
#| eval: true
#| code-line-numbers: false

table(penguins$species, penguins$island)
```

</br>

. . .

::: {.callout-tip}
# Function Design
What do you notice about the layout of the table?
:::

## Designing a `tidy_table()` Function

Based on this exploration, it seems like our function should have the following
qualities:

- accept a data frame
- accept variable names as inputs
- pivot the output to a wide format

## Writing **dplyr** & **tidyr** Code to Accomplish the Task

Using the `penguins` data, write code which will:

- `count()` the number of penguins for each **species** and **island**
- pivot the table to a **wide** format
- replace `NA` values with `0`s

```{r}
#| eval: true
countdown::countdown(minutes = 5)
```

## A Working Solution

```{r}
#| eval: true
#| echo: true
#| code-line-numbers: false

penguins |>
  count(species, island) |>
  pivot_wider(names_from = island, 
              values_from = n, 
              values_fill = 0)
```

## Now let's generalize

::: {.midi}
Now that we have a working example, let's try and generalize our code. 

```{r}
#| echo: true
#| code-line-numbers: false
#| eval: false

df |> 
  count(var1, var2) |> 
  pivot_wider(names_from = var2, 
              values_from = n, 
              values_fill = 0)
```
:::

. . .

::: {.midi}
This works, but maybe we should be more specific about what variables go
where...

```{r}
#| echo: true
#| code-line-numbers: false
#| eval: false

df |> 
  count(row_var, col_var) |> 
  pivot_wider(names_from = col_var, 
              values_from = n, 
              values_fill = 0)
```
:::

## Let's make a function

```{r}
#| echo: true
#| eval: true
#| code-line-numbers: false

tidy_table <- function(df, col_var, row_var){
  
  df |> 
    count(col_var, row_var) |> 
    pivot_wider(names_from = col_var, 
                values_from = n, 
                values_fill = 0)
}
```

## Let's try it out! 

::: columns
::: {.column width="60%"}
```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false

tidy_table(df = penguins, 
           col_var = island, 
           row_var = species)
```

::: {.fragment}
```{r}
#| eval: true
#| error: true

tidy_table(df = penguins, 
           col_var = island, 
           row_var = species)
```
:::
:::

::: {.column width="40%"}
::: {.fragment}
![](images/obama-wtf.gif)
:::
:::
:::

# Indirection

# Indirection

::: {.midi}
The **tidyverse** functions use either "tidy selection" or "data masking." Both
of these features makes common tasks easier at the cost of making less commons
tasks harder. 
:::

## Data Masking -- `count()`

::: {.midi}
Blurs the line between the two different meanings of the word "variable":

- `env-variables` -- "programming" variables that live in an environment
  * These are typically created using a `<-`.

- `data-variables` --- "statistical" variables that live in a data frame. 
    * These come from data files or are created manipulating existing variables.
    
::: {.fragment}
When you have the `data-variable` in a function argument, you need to embrace
the argument. 

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false

count({{ col_var }}, {{ row_var }})
```
:::
:::

## Tidy Select -- `pivot_wider()`

::: {.midi}
In the case of our function, the name of the columns we want to use are stored
in an intermediate variable (e.g., `col_var = island`). 
:::

. . .

</br>

::: {.midi}
When you have the `data-variable` (`col_var`) in an `env-variable` (`df`) that
is a function argument, you embrace the argument by surrounding it in doubled
braces. 

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false

pivot_wider(names_from = {{ col_var }}, 
            values_from = n, 
            values_fill = 0)
```
:::

## Our Updated Function

```{r}
#| echo: true
#| eval: true
#| code-line-numbers: false

tidy_table <- function(df, col_var, row_var){
  df |> 
    count({{ col_var }}, {{ row_var }}) |> 
    pivot_wider(names_from = {{ col_var }}, 
                values_from = n, 
                values_fill = 0)
}
```

::: {.callout-important}
# Update your `tidy_table()` function in your Colab notebook!
:::


## Let's give it another go!

```{r}
#| echo: true
#| eval: true
#| code-line-numbers: false

tidy_table(df = penguins, 
           row_var = species, 
           col_var = island)
```

## What if only one variable was input?

```{r}
#| echo: true
#| eval: true
#| error: true
#| code-line-numbers: false

tidy_table(df = penguins, species)
```

. . .

::: {.callout-important}
# Why didn't this result in an error?
:::

<!-- argument order -->
<!-- plus col_var is the only variable needed for pivoting -->

## Argument order matters!

::: {.midi}
```{r}
#| echo: true
#| eval: true
#| code-line-numbers: "|1"

tidy_table <- function(df, row_var, col_var){
  df |> 
    count({{ col_var }}, {{ row_var }}) |> 
    pivot_wider(names_from = {{ col_var }}, 
                values_from = n, 
                values_fill = 0)
}
```
:::

</br> 

. . .

::: {.midi}
```{r}
#| echo: true
#| eval: true
#| code-line-numbers: false
#| error: true

tidy_table(df = penguins, species)
```
:::

## Check if `row_var` is `missing()`

::: {.midi}
```{r}
#| echo: true
#| eval: true
#| code-line-numbers: false

tidy_table <- function(df, col_var, row_var){
  
  if(missing(row_var)){
    df |> 
    count({{ col_var }}) |> 
    pivot_wider(names_from = {{ col_var }}, 
                values_from = n, 
                values_fill = 0)
  }
  else {
    df |> 
    count({{ col_var }}, {{ row_var }}) |> 
    pivot_wider(names_from = {{ col_var }}, 
                values_from = n, 
                values_fill = 0)
  }
}
```
:::

::: {.callout-important}
# Update your `tidy_table()` function in your Colab notebook!
:::

## Let's try it!

::: {.midi}
```{r}
#| echo: true
#| eval: true
#| code-line-numbers: false

tidy_table(df = penguins, col_var = species)
```
:::

. . .

::: {.midi}
```{r}
#| echo: true
#| eval: true
#| code-line-numbers: false

tidy_table(df = penguins, 
           row_var = island, 
           col_var = species)
```
:::

## What if we wanted to use quoted variable names?

```{r}
#| echo: true
#| eval: true
#| code-line-numbers: false
#| error: true

tidy_table(df = penguins, 
           row_var = "species", 
           col_var = "island")
```

## We need some helper functions!

- For tidy selection, we need to use `all_of()`

::: {.midi}
```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false

pivot_wider(names_from = all_of(col_var), 
                values_from = n, 
                values_fill = 0)
```
:::

. . .

- For data masking, we need to combine `all_of()` with `pick()`

::: {.midi}
```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false

count(
  pick(
    all_of( 
      c(row_var, col_var)
      )
    )
  )
```
:::

## A Character Vector Function

::: {.midi}
```{r}
#| echo: true
#| eval: true
#| code-line-numbers: false

quote_table <- function(df, row_var, col_var){
  df |> 
    count(
      pick(
        all_of(
          c(row_var, col_var)
          )
        )
      ) |> 
    pivot_wider(names_from = all_of(col_var), 
                values_from = n, 
                values_fill = 0)
}
```
:::

::: {.callout-important}
# Add the `quote_table()` function in your Colab notebook!
:::

## Did it work???

```{r}
#| echo: true
#| eval: true
#| code-line-numbers: false

quote_table(df = penguins, 
            row_var = "species", 
            col_var = "island")
```

# Let's take a 5-minute break!

# Our Next Goal

. . .

> Recreate the `prop.table()` function in R


## Let's Explore the `prop.table()` Function First

Let's start with **one** categorical variable.

. . .

```{r}
#| echo: true
#| eval: true
#| code-line-numbers: false

table(penguins$species) |> 
  prop.table()
```

. . .

</br>

::: {.callout-tip}
# Function Design
What do you notice about the proportions?
:::

## Let's Explore the `prop.table()` Function First

Okay, let's add a second categorical variable. 

```{r}
#| echo: true
#| eval: true
#| code-line-numbers: false

table(penguins$species, penguins$island) |> 
  prop.table()
```
::: {.callout-tip}
# Function Design
What do you notice about the proportions?
:::

## An Optional Argument

The `prop.table()` function has an optional `margin` argument. 

```{r}
#| echo: true
#| eval: true
#| code-line-numbers: false

table(penguins$species, penguins$island) |> 
  prop.table(margin = 1)
```

::: {.callout-tip}
# Function Design
What do you notice about the proportions?
:::

## Designing a `tidy_prop_table()` Function

Based on this exploration, it seems like our function should have the following
qualities:

- accept a data frame
- accept variable names as inputs
- pivot the output to a wide format
- calculate joint or marginal proportions for each group

## Writing **dplyr** & **tidyr** Code to Accomplish the Task

Using the `penguins` data, write code which will:

- `count()` the number of penguins for each **species** and **island**
- add a column for the proportion of each group

```{r}
#| eval: true
countdown::countdown(minutes = 3)
```

## A Working Solution 

::: {.midi}
These give proportions for the entire table.

```{r}
#| echo: true
#| eval: true
#| code-line-numbers: false

penguins |> 
  count(species, island) |> 
  mutate(prop = n / sum(n)) 
```
:::

. . .

**What if I wanted marginal proportions for each species?**

## Marginal Proportions for `species`

::: {.midi}
```{r}
#| echo: true
#| eval: true
#| code-line-numbers: false

penguins |> 
  count(species, island) |> 
  group_by(species) |> 
  mutate(prop = n / sum(n)) 
```

::: {.callout-important}
# Notice that there is still a grouping variable?

What should I add to my code?
:::
:::

## Much better!

```{r}
#| echo: true
#| eval: true
#| code-line-numbers: false

penguins |> 
  count(species, island) |> 
  group_by(species) |> 
  mutate(prop = n / sum(n)) |> 
  ungroup()
```


## What about pivoting? 

For this table, we don't care about the counts. Let's add some code that:

- removes the column of counts
- pivots the table to a **wide** format
- replaces `NA` values with `0`s

## A Working Solution 

::: {.midi}
```{r}
#| echo: true
#| eval: true
#| code-line-numbers: false

penguins |> 
  count(species, island) |> 
  group_by(species) |> 
  mutate(prop = n / sum(n)) |> 
  ungroup() |> 
  select(-n) |> 
  pivot_wider(names_from = island, 
              values_from = prop, 
              values_fill = 0)

```
:::


## Now let's generalize!

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false

df |> 
  count(row_var, col_var) |> 
  group_by(col_var) |> 
  mutate(prop = n / sum(n)) |> 
  ungroup() |> 
  select(-n) |> 
  pivot_wider(names_from = col_var,
              values_from = prop, 
              values_fill = 0)
```

## Let's make a function

```{r}
#| echo: true
#| eval: true
#| code-line-numbers: false
 
tidy_prop_table <- function(df, col_var, row_var){
  
  df |> 
    count({{ row_var }}, {{ col_var }}) |> 
    group_by({{ col_var }}) |> 
    mutate(prop = n / sum(n)) |> 
    ungroup() |> 
    select(-n) |> 
    pivot_wider(names_from = {{ col_var }},
                values_from = prop, 
                values_fill = 0)
  
}

```

## Let's try it out!

```{r}
#| echo: true
#| eval: true
#| code-line-numbers: false

tidy_prop_table(df = penguins, 
                row_var = species, 
                col_var = island)
```

## What if I wanted to get marginal proportions for the `row_var`?

. . .

</br>

::: {.midi}
The `margin` argument of `prop.table()` has the following behavior:

- when no margin is specified the proportions are joint
- when `margin = 1` the proportions are conditional on the **rows**
- when `margin = 2` the proportions are conditional on the **columns**
:::

## A Pseudocode Design

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false

if( margin is missing){
  calculate joint proportions
} 

else if(margin is rows){
  calculate marginal proportions based on row variable
}

else {
  calculate marginal proportions based on column variable
}
```

## Moving into R Code

```{r}
#| echo: true
#| eval: true
#| code-line-numbers: false

tidy_prop_table <- function(df, col_var, row_var, margin = NULL){

  # Default to joint proportions
  if(is.null(margin)){
    df |>
    count({{ row_var }}, {{ col_var }}) |>
    mutate(prop = n / sum(n)) |>
    ungroup() |>
    select(-n) |>
    pivot_wider(id_cols = {{ row_var }},
                names_from = {{ col_var }},
                values_from = prop,
                values_fill = 0)
  }
  else if(margin == "row"){
    df |>
      count({{ row_var }}, {{ col_var }}) |>
      group_by({{ row_var }}) |>
      mutate(prop = n / sum(n)) |>
      ungroup() |>
      select(-n) |>
      pivot_wider(id_cols = {{ row_var }},
                  names_from = {{ col_var }},
                  values_from = prop,
                  values_fill = 0) |>
      print()
  }
  else{
    df |>
      count({{ row_var }}, {{ col_var }}) |>
      group_by({{ col_var }}) |>
      mutate(prop = n / sum(n)) |>
      ungroup() |>
      select(-n) |>
      pivot_wider(id_cols = {{ row_var }},
                  names_from = {{ col_var }},
                  values_from = prop,
                  values_fill = 0)
  }

}

```


## How'd we do?

**Joint Proportions**

::: {.midi}
```{r}
#| echo: true
#| eval: true
#| code-line-numbers: false

tidy_prop_table(df = penguins, 
                col_var = species, 
                row_var = island)
```
:::

## How'd we do?

**Marginal Proportions -- Rows**

::: {.midi}
```{r}
#| echo: true
#| eval: true
#| code-line-numbers: false

tidy_prop_table(df = penguins, 
                col_var = species, 
                row_var = island, 
                margin = "row")

```
:::

## How'd we do?

**Marginal Proportions -- Columns**

::: {.midi}
```{r}
#| echo: true
#| eval: true
#| code-line-numbers: false

tidy_prop_table(df = penguins, 
                col_var = species, 
                row_var = island, 
                margin = "col")
```
:::


# What questions do we have?

<!-- # Lab 8 -->

<!-- ## Functions  -->
<!-- I didn't talk about the walrus operator -->

