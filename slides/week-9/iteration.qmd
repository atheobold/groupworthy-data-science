---
title: "Iteration"
format: 
  revealjs:
      theme: [simple, ../style.scss]
      auto-stretch: false
editor: source
execute:
  echo: true
---

```{r setup}
#| include: false
#| message: false

library(tidyverse)
library(palmerpenguins)
```

## Today we will...

+ New Material
  + Performing Repeated Tasks + Vectorization
  + Functional Programming: the `map()` family
+ Lab 8 Recap
+ Lab 9 Preview

# It's Week 8 (or 9)...

. . .

> How are you taking care of yourself?

# Performing Repeated Tasks

## Repetition

Type out the task over and over.

```{r}
#| echo: false
#| fig-align: center
#| fig-alt: "The image shows a chalkboard scene styled after The Simpsons with Bart Simpson standing beside a chalkboard, where he has written repeatedly in large, white text: 'I WILL NOT USE LOOPS IN R.' This is a humorous reference to programming practices in R, suggesting a preference for avoiding loops in favor of other approaches. Bart is holding a piece of chalk and looking over his shoulder at the viewer with a mischievous expression."
#| out-width: 50%

knitr::include_graphics("images/bart_board_iter.png")
```

. . .

Do not do this.

## Iteration

Repeatedly execute the *same* operation over and over.

. . .

+ Loops (e.g., `for()` and `while()`) allow us to iterate.

. . .

:::: {.columns}
::: {.column width="40%"}
```{r}
#| echo: true
#| code-line-numbers: false

for(i in 1:6){
  print(i^2)
}
```

:::
::: {.column width="60%"}
```{r}
#| echo: false
#| fig-align: center
#| out-width: 80%
#| fig-alt: "The image shows a chalkboard with Bart Simpson standing beside it, holding a piece of chalk. The chalkboard displays R code that humorously contradicts the message by using a loop to discourage using loops in R. The code reads: `FOR (I IN 1:100) { PRINT(I WILL NOT USE LOOPS IN R) }`. This satirical twist emphasizes a preference in R programming for avoiding traditional loops in favor of functional programming methods. Bart appears to be looking at the code on the chalkboard."

knitr::include_graphics("images/bart_board_for.png")
```
:::
::::

## Vectorization

Many operations in R are **vectorized**.

+ These functions operate on *vectors* of values rather than a *single* value.
+ We can iterate *without* writing a loop.

. . .

```{r}
#| echo: true
#| code-line-numbers: false

x <- seq(from = -4, to = 6)
```

. . .

::: columns
::: {.column width="47%"}
```{r}
#| echo: true
#| code-line-numbers: false

abs(x)
```
:::

::: {.column width="3%"}
:::

::: {.column width="50%"}
::: {.fragment}
```{r}
#| echo: true
#| code-line-numbers: false

for(i in 1:length(x)){
  x[i] <- abs(x[i])
}

x
```
:::
:::
:::

## Vectorization

**Not every function is vectorized.**

+ For example, `if()` statements **cannot** operate on vectors.

. . .

:::: {.columns}
::: {.column width="55%"}
```{r}
#| error: true
#| echo: true
#| code-line-numbers: false

pos_neg_zero <- function(x){
  if(x > 0){
    return("Greater than 0!")
  } 
  else if (x < 0){
    return("Less than 0!")
  } 
  else {
    return("Equal to 0!")
  }
}
```

:::
::: {.column width="45%"}

```{r}
#| echo: false
x <- seq(from = -4, to = 6)
```

::: {.fragment}
```{r}
#| error: true
#| echo: true
#| code-line-numbers: false

pos_neg_zero(x)
```
:::

::: {.fragment}
::: {.midi}
This means that `if(x > 0)` can only be checked for something of length 1 (a 
single number, not a vector).
:::
:::
:::
::::


## What do we do instead?

. . .

**Option 1 -- Looping**

```{r}
#| code-line-numbers: false

result <- rep(NA, length(x))

for(i in 1:length(x)){
  result[i] <- pos_neg_zero(x[i])
}

result
```


## What do we do instead?

. . .

**Option 2 -- Write a Vectorized Function**

::: {.midi}
`if_else()` and `case_when()` are the **vectorized** versions of `if()` and 
`else if()`
:::

. . .

```{r}
#| error: true
#| echo: true
#| code-line-numbers: false

pos_neg_zero <- function(x){
  case_when(x > 0 ~ "Greater than 0!", 
            x < 0 ~ "Less than 0!", 
            .default = "Equal to 0!")
}
```

. . .

```{r}
#| error: true
#| echo: true
#| code-line-numbers: false

pos_neg_zero(x)
```

<!-- talk about the difference between using an if() for an input check and using if() to determine what values -->

<!-- if(aes = "fill") then do this -->

<!-- if(aes = "color") then do this -->

## Some functions cannot be vectorized!

. . .

Applying `class()` to a **single** variable in a data frame returns the data type
of that column:

```{r}
#| code-line-numbers: false

class(penguins[["species"]])
```

. . .

</br>

Trying to apply `class()` to **every** variable in a data frame returns the data
type of the data frame:

```{r}
#| code-line-numbers: false

class(penguins)
```

## What can we do instead?

Write a `for()` loop...

```{r}
#| code-line-numbers: false

data_type <- rep(NA, length = ncol(penguins))

for(i in seq_along(penguins)){
  data_type[i] <- class(penguins[[i]])
}
```

. . .

```{r}
#| code-fold: true

tibble(column = names(penguins), 
       type = data_type) |> 
  pivot_wider(names_from = column, 
              values_from = type) |>  
  knitr::kable() |>
  kableExtra::kable_styling(font_size = 30)
```


# ...but loops are computationally intensive


## What can we do instead?

What about `across()`?

```{r}
#| code-line-numbers: "2-4"

penguins |> 
  summarise(
    across(.cols = everything(),
           .fns = ~ class(.x)
           )
            ) |>  
  knitr::kable() |>
  kableExtra::kable_styling(font_size = 30)
```

## But `across()` uses a `for()` loop!

</br>
</br>

::: {.centered}
::: {.large}
```
for (j in seq_fns) {
  fn <- fns[[j]]
  out[[k]] <- fn(col, ...)
  k <- k + 1L
```
:::
:::

# Functional Programming

. . .

> To understand computations in R, two slogans are helpful:
> 
> - Everything that exists is an object.
> 
> - Everything that happens is a function call.
> 
> John Chambers (creator of the pre-cursor to R)


## Functional Programming -- Big Picture

We will use **functions** as the **arguments** to other functions!

<br>

::: callout-note
There are a slew of `apply()` functions you will likely come across.

We will instead focus on the `purrr` package and the `map()` family of functions.
:::


## `purrr`

:::: {.columns}
::: {.column width="80%"}
The `purrr` package breaks common list manipulations into small, independent pieces.

</br>

This strategy involves two steps:

:::
::: {.column width="20%"}
![](images/purrr.png){width=80% fig-alt="The image is a hexagonal logo for the R package purrr. It features a simple, hand-drawn outline of a content, sleeping cat with closed eyes, representing the package's name, which sounds like a cat's purr. The logo's design conveys a sense of calm and ease, suggesting that the purrr package makes functional programming in R more intuitive and manageable."}
:::
::::

. . .

1. Break a complex problem into smaller **sub-problems**.

. . .

2. Solve each sub-problem for **a single element** of a list.
    + Once done, `purrr` will generalize the solution to every element in the list.


## `map()`

The `map()` function **iterates** through each item in a list and applies a function, then returns the new list.

```{r}
#| fig-align: center
#| out-width: 30%
#| echo: false
#| fig-alt: "The image illustrates the concept of a mapping function in programming, specifically in the context of applying a function to each element of a list or vector. On the left, there is a vertical stack of colored blocks in varying shades of orange, representing individual elements. The text `map( , f)` suggests the application of a function f to each element in the sequence. An arrow points to the right, leading to a new vertical stack where each block is enclosed in a box labeled `f()`, indicating that the function `f` has been applied to each element individually. This visual representation demonstrates how mapping functions work by transforming each element in a sequence."

knitr::include_graphics("images/map.png")
```

::: {.callout-tip}
# Using the |> 

The first argument in `map()` is the list, so if we pipe into it, we **only**
specify the function we want to iterate!
:::

## `map()` + Dataframes

A data frame is just a list of columns -- `map()` will apply a function to every column.

. . .

::: columns
::: {.column width="65%"}
```{r}
#| code-line-numbers: false

penguins |> 
  select(where(is.numeric)) |>
  map(.f = ~ mean(.x, na.rm = TRUE))
```

:::

::: {.column width="5%"}
:::

::: {.column width="30%"}
::: {.fragment}
Use a lambda function (with `~` and `.x`), just like in `across()`!
:::
:::
:::


## The `map()` Family

The `map_xxx()` variants allow you to specify the **type of output** you want.

+ `map()` creates a *list*.
+ `map_chr()` creates a *character vector*.
+ `map_lgl()` creates an *logical vector*.
+ `map_int()` creates a *integer vector*.
+ `map_dbl()` creates a *numeric vector*.

All take in a list (`.x`) and a function (`.f`) as arguments.

## `map()` + penguins

::: panel-tabset

### `map_dbl()`

::: {.midi}

> Output is a **vector of doubles**

::: {.fragment}
Calculate the mean of each penguin measurement column.

```{r}
#| code-line-numbers: false

penguins |> 
  select(starts_with(c("bill", "body", "flipper"))) |> 
  map_dbl(.f = ~ mean(.x, na.rm = TRUE)) 
```
:::
:::

### `map_int()`

::: {.midi}

> Output is a **vector of integers**.

::: {.fragment}
Calculate the number of `NA`s in each column.

```{r}
#| code-line-numbers: false

penguins |> 
  map_int(.f = ~ sum(is.na(.x)))
```
:::
:::

### `map_lgl()`

::: {.midi}
> Output is a **vector of logicals**

::: {.fragment}
Calculate the number of `NA`s in each column.

```{r}
#| error: true
#| code-line-numbers: false

penguins |> 
  map_lgl(.f = ~ sum(is.na(.x)))
```

R returns an error if the output is of the wrong type!

:::
:::
:::


## Comparing Speed

Using functional programming can be **much faster** than using `for` loops.

::: panel-tabset

### `for()`

```{r}
#| echo: true
#| code-line-numbers: false

loop_func <- function(df){
  typ <- rep(NA, ncol(df))
  for(i in 1:ncol(df)){
    typ[i] <- class(df[[i]])
  }
  return(typ)
}
```

### `map()`

```{r}
#| echo: true
#| code-line-numbers: false

map_func <- function(df){
  map_chr(df, .f = ~ class(.x))
}
```

### Run

```{r}
#| echo: true
#| code-line-numbers: false

df <- as.data.frame(matrix(1, nrow = 5, ncol = 7))

```

::: columns
::: {.column width="47%"}
```{r}
#| code-line-numbers: false

loop_func(df)
```

:::

::: {.column width="3%"}
:::

::: {.column width="47%"}
```{r}
#| code-line-numbers: false

map_func(df)
```

:::
:::

### Compare

::: {.small}
```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false

microbenchmark::microbenchmark(loop_func(df),
                               map_func(df),
                               times = 20)
```
:::

![](images/speed.png){fig-alt="The image shows a benchmarking result table comparing the execution times of two functions, loop_func(df) and map_func(df), in milliseconds. The table has columns labeled expr, min, lq, mean, median, uq, max, and neval. For loop_func(df), the mean time is approximately 7182.34 milliseconds, with a minimum of 6996.32 milliseconds and a maximum of 8215.57 milliseconds. For map_func(df), the mean time is about 61.49 milliseconds, with a minimum of 54.02 milliseconds and a maximum of 135.86 milliseconds. The results show that map_func(df) performs significantly faster than loop_func(df). Both functions were evaluated 20 times, as indicated in the times column of the microbenchmark function call."}

:::


## `map_if()`

The `map_if()` function allows us to **conditionally** apply a function to each item in a list.

. . .

::: panel-tabset

### `across()`

::: {.midi}
```{r}
#| eval: false
#| code-line-numbers: false

penguins |> 
  mutate(across(.cols = where(is.numeric), 
                .fns = ~ scale(.x, center = TRUE, scale = TRUE)
                )
         )
```

```{r}
#| echo: false
penguins |> 
  select(species:bill_depth_mm, sex) |> 
  mutate(across(.cols = where(is.numeric), 
                .fns = ~ scale(.x, center = TRUE, scale = TRUE)
                )
         ) |> 
  head(n = 8)
```
:::

### `map_if()`

::: {.midi}
```{r}
#| code-line-numbers: false

penguins |> 
  map_if(.p = is.numeric, .f = ~ scale(.x, center = TRUE, scale = TRUE))
```
:::

### `map_if()` to data frame

::: {.midi}
```{r}
#| eval: false
#| code-line-numbers: false

penguins |> 
  map_if(.p = is.numeric, .f = ~ scale(.x, center = TRUE, scale = TRUE)) |> 
  bind_cols()
```

```{r}
#| echo: false
penguins |> 
  map_if(.p = is.numeric, .f = ~ scale(.x, center = TRUE, scale = TRUE)) |> 
  bind_cols() |> 
  select(species, island, bill_length_mm, bill_depth_mm) 
```
:::
:::

## `map_int()` to a data frame

The `enframe()` function converts a named vector to a data frame. 

```{r}
#| echo: true
#| code-line-numbers: false

penguins |> 
  map_int(.f = ~ sum(is.na(.x))) |> 
  enframe()

```

## `map_int()` to a data frame

You can set the names of the columns!

```{r}
#| echo: true
#| code-line-numbers: false

penguins |> 
  map_int(.f = ~ sum(is.na(.x))) |> 
  enframe(name = "Variable", 
          value = "Number Missing")

```

## Use functional programming!

```{r}
#| echo: false
#| fig-align: center
#| out-width: 70%
#| fig-alt: "The image shows a chalkboard with Bart Simpson standing beside it, holding a piece of chalk. The chalkboard contains R code that encourages the use of mapping functions instead of loops. The code reads: `S <- I WILL REPLACE LOOPS BY MAPPING FUNCTIONS`, `V <- REP(S, 100)`, and `PURRR::MAP_CHR(V, PRINT)`. This is a humorous take on functional programming in R, advocating for the use of functions from the purrr package as an alternative to traditional loops. Bart looks toward the chalkboard with a satisfied expression."

knitr::include_graphics("images/bart_board_map.png")
```

# Lab 8: Searching for Efficiency

> Revisit previous lab problems through the lens of efficiency

> - Use functions from `map()` instead of `across()`
> - Reduce separate pipelines into a single pipeline


# Lab 8: Making Great Tables

## Simple Tables

-   the `kable()` function from the **knitr** package
-   the `gt()` function from the **gt** package

## More Sophisticated Tables

- The [**kableExtra** package](https://haozhu233.github.io/kableExtra/awesome_table_in_html.html)

- Add-on functions from the [**gt** package](https://gt.rstudio.com/) (e.g., `cols_label()`, `tab_header()`, `fmt_percent()`)

## Interactive Tables

The `datatable()` function from the **DT** package!

. . .


```{r}
#| echo: true
#| code-line-numbers: false

library(DT)
datatable(penguins)
```

## Adding Color to cells

![](images/nfl-table.png)

## Adding Color to Cells

![](images/womens-world-cup-table.png)

# Lab 7 & Challenge 7 Revisions

## Input Checks

What types of inputs do your functions expect?

. . .

::: {.midi}
- numbers?

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false

stopifnot("Input vector must be numeric" = is.numeric(vec))
```
:::

. . .

::: {.midi}
- values greater than 0?

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false

stopifnot("Input vector must be numeric" = is.numeric(vec), 
          "Input vector must have values larger than 0" = any(vec > 0))
``` 
:::

. . .

::: {.midi}
- vectors of the same length?

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false

stopifnot("Input vector must be numeric" = is.numeric(vec), 
          "Input vector must have values larger than 0" = any(vec > 0), 
          "Max must be a scaler value" = length(max) == 1, 
          "Min must be a scaler value" = length(min) == 1)
``` 
:::

# Clear & Creative Plots

```{r}
#| label: data-function-lab-7
#| echo: false

fish <- read_csv(here::here("labs", "instructions", "data", "BlackfootFish.csv")) |> 
  mutate(length = length / 10) 

impossible_to_NA <- function(x, min, max) {
  case_when(
    x < min ~ NA,
    x > max ~ NA,
    .default = x
  )
}

fish <- fish |> 
  mutate(length = impossible_to_NA(length, min = 5, max = 80),
         weight = impossible_to_NA(weight, min = 10, max = 4000)
         )

condition_index <- function(length, weight) {
  (weight / (length^3)) * 100
}
```


## Missing Values

::: {.small}
```{r}
#| echo: true
#| code-fold: true

fish |>
  mutate(has_missing = if_any(weight, is.na),
         trip = fct_recode(factor(trip),
                      "First Survey (Trip 1)" = "1",
                      "Second Survey (Trip 2)" = "2")) |>
  group_by(year, section, trip) |>
  summarize(
    n_missing = sum(has_missing),
    n_total = n(),
    pct_missing = (n_missing / n_total) * 100,
    .groups = "drop"
  ) |>
  ggplot(aes(x = factor(year), 
             y = n_missing, 
             fill = section)) +
  geom_col(position = "dodge", 
           color = "white", 
           linewidth = 0.3) +
  geom_text(aes(label = n_missing), 
            position = position_dodge(width = 0.9),
            vjust = -0.5, 
            size = 3) +
  facet_wrap(~trip) +
  labs(
    x = "",
    y = "",
    fill = "River Section",
    title = "Missing Values in Fish Measurements by Year, Section, and Trip",
    subtitle = "Rainbow and brown trout measurements across the Blackfoot River"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 13),
    plot.subtitle = element_text(size = 10, color = "gray40"),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "bottom"
  ) +
  scale_fill_brewer(palette = "Set1")
```
:::

## Condition Indices

::: {.small}
```{r}
#| echo: true
#| code-fold: true

mycolors <- RColorBrewer::brewer.pal(8, "BrBG")[c(3, 2, 1, 8)] # color palette
  
fish |> 
  mutate(condition = condition_index(length, weight)) |> 
  group_by(year, species) |> 
  summarize(mean_condition = mean(condition, na.rm = TRUE),
            .groups = "drop") |> 
  mutate(species = fct_reorder2(.f = species,
                               .x = year,
                               .y = mean_condition)) |> 
  ggplot(mapping = aes(x = year, y = mean_condition, color = species)) +
  geom_rug(sides = "b", color = "gray85", lineend = "round", length = unit(100, "npc")) +
  geom_smooth(se = FALSE) +
  geom_point() +
  theme_linedraw() +
  scale_color_manual(values = mycolors,
                     labels = c("Rainbow Trout",
                                "Brown Trout",
                                "Westslope Cutthroat Trout",
                                "Bull Trout")) +
  scale_x_continuous(breaks = seq(1988, 2007, by = 1)) +
  theme(axis.text.x = element_text(size = 7),
        panel.grid.minor.x = element_blank(),
        panel.grid.major.x = element_blank(),
        plot.title = element_text(face = "bold"),
        plot.caption.position = "plot") +
  labs(title = "Bull Trout in Worse Condition than Other Trout Species",
       subtitle = "Mean Condition Index",
       x = NULL,
       y = NULL,
       color = "Trout Species",
       caption = "Fish captured on the Blackfoot River outside Helena, Montana")
```
:::

## Removing Your Legend

::: {.small}
```{r}
#| echo: true
#| code-fold: true

fish |>
  group_by(year, section, trip) |>
  summarize(missing_count = sum(is.na(weight)), 
            .groups = "drop") |>
  mutate(trip = if_else(trip == 1,
                        "Trip 1",
                        "Trip 2")
         ) |>
  ggplot(aes(x = year, y = missing_count, color = section)) +
  geom_line(size = 1) +
  scale_color_brewer(palette = "Set2") +
  labs(
    title = str_c("Missing Fish Weights for the ",
      "<span style = 'color:#66C2A5'>**Johnsrud**</span>",
      " and <span style = 'color:#FC8D62'>**ScottyBrown**</span>",
      " Sections of the Blackfoot River"),
    x = "",
    y = "",
    color = "Section") +
  facet_wrap(~ trip) +
  theme_minimal() + 
  theme(plot.title = ggtext::element_markdown(size = 16), 
        legend.position = "none",
        axis.text.x = element_text(size = 12), 
        axis.text.y = element_text(size = 12), 
        axis.title = element_text(size = 12),
        strip.text.x = element_text(size = 12)
        )
```
:::

## Using Annotations Instead

::: {.small}
```{r}
#| echo: true
#| code-fold: true

plot <- fish |>
  group_by(year, section, trip) |>
  summarize(missing_count = sum(is.na(weight)), .groups = "drop") |>
  mutate(trip = case_when(
    trip == 1 ~ "Trip 1",
    trip == 2 ~ "Trip 2")) |>
  ggplot(aes(x = year, y = missing_count, color = section)) +
  geom_line(linewidth = 1) +
  scale_color_brewer(palette = "Set2") +
  labs(
    title = "Missing Fish Weights for Trout Species on the Blackfoot River in Montana",
    x = "",
    y = "",
    color = "Section") +
  facet_wrap(~ trip) +
  theme_minimal() +
  theme(legend.position = "none", 
        plot.title = element_text(size = 18), 
        axis.text.x = element_text(size = 12), 
        axis.text.y = element_text(size = 12)
        )


annotate_text <- data.frame(year = c(1994, 1993), 
                            missing_count = c(150, 40),
                            trip = factor(c("Trip 2", "Trip 2"), 
                                          levels = c("Trip 1","Trip 2"), 
                                          ), 
                            section = factor(c("Johnsrud", "ScottyBrown"), 
                                             levels = c("Johnsrud", "ScottyBrown"))
                            )
plot + 
  geom_text(data = annotate_text, label = c("Johnsrud", "ScottyBrown"))
  
```
:::
